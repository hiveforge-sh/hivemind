---
phase: 11-server-template-integration-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/server.ts
  - tests/integration/server-init.test.ts
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "initializeTemplates() is called during server startup"
    - "Template registry is populated with worldbuilding template by default"
    - "All 16 dynamic MCP tools (query_X, list_X) are available at runtime"
    - "Server logs active template name on startup"
    - "Existing vaults work with template system after fix"
  artifacts:
    - path: "src/server.ts"
      provides: "Template initialization during server startup"
      contains: "initializeTemplates"
    - path: "tests/integration/server-init.test.ts"
      provides: "Integration test for template loading"
      min_lines: 30
  key_links:
    - from: "src/server.ts"
      to: "src/templates/loader.ts"
      via: "import { initializeTemplates }"
      pattern: "import.*initializeTemplates.*from.*templates/loader"
    - from: "src/server.ts:start()"
      to: "templateRegistry"
      via: "initializeTemplates() call"
      pattern: "initializeTemplates\\(\\)"
---

<objective>
Restore template initialization in server startup to activate all v2.0 features.

Purpose: The v2.0 Template System is fully built (22 requirements, 458 tests pass) but disconnected. All code exists but `initializeTemplates()` is never called from `src/server.ts`, causing the template registry to be empty at runtime. This makes all 16 dynamic MCP tools (query_X, list_X) return empty arrays.

Output: Working template system integration with server startup, verified by integration test and human testing with real vault.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Key source files
@src/server.ts
@src/templates/loader.ts
@tests/integration/vault-graph-search.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template initialization to server startup</name>
  <files>src/server.ts</files>
  <action>
Add the template initialization import and call to `src/server.ts`:

1. Add import at top of file (after existing template imports around line 22):
```typescript
import { initializeTemplates } from './templates/loader.js';
```

2. Add initialization call at the START of the `start()` method (before vault scan, around line 1531):
```typescript
async start(): Promise<void> {
  // Initialize template system
  console.error('[Server] Initializing template system...');
  try {
    const config = initializeTemplates();
    console.error(`[Server] Template initialized: ${config.activeTemplate}`);
  } catch (err) {
    console.error('[Server] Warning: Template init failed:', err);
    // Continue without templates - backwards compatibility
  }

  // Initial vault scan (existing code)
  console.error('Performing initial vault scan...');
  // ... rest of existing start() method
```

Important:
- Template init MUST happen BEFORE vault scan (templates need to be registered before entity parsing)
- Wrap in try-catch for backwards compatibility (vaults without config still work)
- Log active template name for debugging visibility
- Do NOT modify any other code in start() method
  </action>
  <verify>
1. Run `npm run build` - TypeScript compiles without errors
2. Run `npm test` - All 458+ tests pass
3. Grep for pattern: `grep -n "initializeTemplates" src/server.ts` shows import and call
  </verify>
  <done>
- Import statement exists: `import { initializeTemplates } from './templates/loader.js'`
- `initializeTemplates()` called at start of `start()` method
- Wrapped in try-catch for error handling
- Logs active template name
- All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for server template initialization</name>
  <files>tests/integration/server-init.test.ts</files>
  <action>
Create new integration test file `tests/integration/server-init.test.ts`:

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { templateRegistry } from '../../src/templates/registry.js';
import { initializeTemplates } from '../../src/templates/loader.js';

describe('Integration: Server Template Initialization', () => {
  beforeEach(() => {
    // Clear registry before each test
    templateRegistry.clear();
  });

  afterEach(() => {
    // Clean up registry after each test
    templateRegistry.clear();
  });

  describe('initializeTemplates()', () => {
    it('should register worldbuilding template by default', () => {
      const config = initializeTemplates();

      expect(config.activeTemplate).toBe('worldbuilding');
      expect(templateRegistry.has('worldbuilding')).toBe(true);
    });

    it('should register all built-in templates', () => {
      initializeTemplates();

      expect(templateRegistry.has('worldbuilding')).toBe(true);
      expect(templateRegistry.has('research')).toBe(true);
      expect(templateRegistry.has('people-management')).toBe(true);
    });

    it('should activate worldbuilding template', () => {
      initializeTemplates();

      const active = templateRegistry.getActive();
      expect(active).not.toBeNull();
      expect(active?.id).toBe('worldbuilding');
    });

    it('should have entity types available after initialization', () => {
      initializeTemplates();

      // Check worldbuilding entity types are accessible
      const character = templateRegistry.getEntityType('character');
      const location = templateRegistry.getEntityType('location');

      expect(character).not.toBeNull();
      expect(location).not.toBeNull();
      expect(character?.name).toBe('character');
      expect(location?.name).toBe('location');
    });

    it('should have relationship types available after initialization', () => {
      initializeTemplates();

      const relationships = templateRegistry.getRelationshipTypes();

      expect(relationships.length).toBeGreaterThan(0);
      // Worldbuilding has 'appears_in' relationship
      expect(relationships.some(r => r.id === 'appears_in')).toBe(true);
    });
  });
});
```

Test covers:
- Default worldbuilding template is registered and active
- All 3 built-in templates are registered
- Entity types are accessible via registry
- Relationship types are accessible via registry
  </action>
  <verify>
1. Run `npm test tests/integration/server-init.test.ts` - All tests pass
2. Run `npm test` - Full test suite passes (no regressions)
  </verify>
  <done>
- Test file exists at `tests/integration/server-init.test.ts`
- Tests verify template registration and activation
- Tests verify entity types and relationship types are available
- All tests pass
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Template system integration with server startup:
1. `initializeTemplates()` now called in `server.ts` start() method
2. Template registry populated with worldbuilding template by default
3. Integration tests verify correct initialization
  </what-built>
  <how-to-verify>
1. Start the server with your real vault:
   ```bash
   npx ts-node src/index.ts --vault /path/to/your/vault
   ```
   Or use your normal startup command.

2. Check console output for:
   - `[Server] Initializing template system...`
   - `[Server] Template initialized: worldbuilding`

3. Test with Claude Desktop or MCP inspector:
   - Run `list_characters` or `query_character` tool
   - Should return actual data (not empty array)

4. Verify all 16 dynamic tools work:
   - query_character, list_characters
   - query_location, list_locations
   - query_event, list_events
   - query_faction, list_factions
   - query_lore, list_lores
   - query_asset, list_assets
   - query_worldbuilding_note, list_worldbuilding_notes
   - query_timeline, list_timelines

Expected: Tools return real data from your vault, not empty arrays.
  </how-to-verify>
  <resume-signal>Type "approved" if tools work with your vault, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
Overall verification for this gap closure:

1. **Build passes:** `npm run build` completes without errors
2. **Tests pass:** `npm test` shows all tests passing (including new integration tests)
3. **Template initialized at startup:** Server logs show template initialization
4. **Dynamic tools work:** MCP tools return real data, not empty arrays
</verification>

<success_criteria>
Phase 11 is complete when:

1. [x] `initializeTemplates()` import added to `src/server.ts`
2. [x] `initializeTemplates()` called in server `start()` method (before vault scan)
3. [x] Template initialization wrapped in try-catch for backwards compatibility
4. [x] Server logs active template name on startup
5. [x] Integration test `tests/integration/server-init.test.ts` exists and passes
6. [x] All 458+ existing tests still pass
7. [x] Human verified: Real vault works with template system
8. [x] Human verified: Dynamic MCP tools return actual data
</success_criteria>

<output>
After completion, create `.planning/phases/11-server-template-integration-fix/11-01-SUMMARY.md`
</output>
