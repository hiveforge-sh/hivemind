---
phase: 12-setup-wizard
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - src/cli/init/output.ts
  - src/cli/init/index.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "User receives config.json with vault path and template settings"
    - "User sees Claude Desktop config snippet formatted for easy copy"
    - "User can copy config to clipboard after being asked"
    - "Non-interactive mode works with --config preset.json flag"
    - "Non-interactive mode works with --vault and --template flags"
  artifacts:
    - path: "src/cli/init/output.ts"
      provides: "Config file generation and Claude Desktop snippet output"
      exports: ["generateConfig", "generateClaudeDesktopSnippet", "writeConfigFile", "outputNextSteps"]
    - path: "src/cli/init/index.ts"
      provides: "Main init entry point combining all init modules"
      exports: ["initCommand"]
    - path: "src/cli.ts"
      provides: "Updated CLI entry point routing to new init"
      contains: "initCommand"
  key_links:
    - from: "src/cli/init/index.ts"
      to: "src/cli/init/wizard.ts"
      via: "import runInteractiveWizard"
      pattern: "import.*runInteractiveWizard.*from.*wizard"
    - from: "src/cli/init/index.ts"
      to: "src/cli/init/output.ts"
      via: "import"
      pattern: "import.*from.*output"
    - from: "src/cli.ts"
      to: "src/cli/init/index.ts"
      via: "import initCommand"
      pattern: "import.*initCommand.*from.*cli/init"
---

<objective>
Create config generation, Claude Desktop snippet output, and wire the new init command into the CLI.

Purpose: Completes the wizard by generating output files and enabling non-interactive mode for CI/automation.
Output: Working init command with both interactive and non-interactive modes.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-setup-wizard/12-CONTEXT.md
@.planning/phases/12-setup-wizard/12-RESEARCH.md
@src/cli/init/wizard.ts
@src/cli/init/validators.ts
@src/cli/shared/clipboard.ts
@src/cli/shared/colors.ts
@src/cli.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output module for config generation</name>
  <files>src/cli/init/output.ts</files>
  <action>
Create src/cli/init/output.ts for config file and Claude Desktop snippet generation:

```typescript
import { writeFileSync } from 'fs';
import { resolve } from 'path';
import { copyToClipboard } from '../shared/clipboard.js';
import { promptConfirm } from './prompts.js';
import { success, error, dim, bold } from '../shared/colors.js';

/**
 * Hivemind config.json structure.
 */
export interface HivemindConfig {
  vault: {
    path: string;
    watchForChanges: boolean;
    debounceMs: number;
  };
  server: {
    transport: 'stdio';
  };
  template: {
    activeTemplate: string;
  };
  indexing: {
    strategy: 'incremental';
    batchSize: number;
    enableVectorSearch: boolean;
    enableFullTextSearch: boolean;
  };
}

/**
 * Generate Hivemind config object.
 */
export function generateConfig(vaultPath: string, templateId: string): HivemindConfig {
  return {
    vault: {
      path: vaultPath,
      watchForChanges: true,
      debounceMs: 100,
    },
    server: {
      transport: 'stdio',
    },
    template: {
      activeTemplate: templateId,
    },
    indexing: {
      strategy: 'incremental',
      batchSize: 100,
      enableVectorSearch: false,
      enableFullTextSearch: true,
    },
  };
}

/**
 * Generate Claude Desktop MCP config snippet.
 */
export function generateClaudeDesktopSnippet(vaultPath: string): string {
  const config = {
    mcpServers: {
      hivemind: {
        command: 'npx',
        args: ['-y', '@hiveforge/hivemind-mcp', '--vault', vaultPath],
      },
    },
  };

  return JSON.stringify(config, null, 2);
}

/**
 * Write config.json to disk.
 */
export function writeConfigFile(dir: string, config: HivemindConfig): string {
  const configPath = resolve(dir, 'config.json');
  writeFileSync(configPath, JSON.stringify(config, null, 2));
  return configPath;
}

/**
 * Output final summary and next steps.
 * Offers to copy Claude Desktop config to clipboard.
 */
export async function outputNextSteps(
  vaultPath: string,
  templateId: string,
  configPath: string,
  isInteractive: boolean
): Promise<void> {
  console.log('\n' + success('Setup complete!'));
  console.log(`\nCreated: ${bold(configPath)}`);
  console.log(`Template: ${templateId}`);

  // Generate and display Claude Desktop snippet
  const snippet = generateClaudeDesktopSnippet(vaultPath);
  console.log('\n' + bold('Claude Desktop configuration:'));
  console.log(dim('Add this to your claude_desktop_config.json:\n'));
  console.log(snippet);

  // Offer to copy to clipboard (only in interactive mode)
  if (isInteractive && process.stdin.isTTY) {
    const shouldCopy = await promptConfirm('Copy to clipboard?', true);
    if (shouldCopy) {
      const copied = await copyToClipboard(snippet);
      if (copied) {
        console.log(success('\nCopied to clipboard!'));
      } else {
        console.log(dim('\nCould not copy to clipboard (clipboard may not be available).'));
      }
    }
  }

  // Next steps
  console.log('\n' + bold('Next steps:'));
  console.log('  1. Paste the config into Claude Desktop settings');
  console.log('  2. Restart Claude Desktop');
  console.log('  3. Add frontmatter to your vault files');
  console.log('  4. Start querying via Claude!\n');

  console.log(dim('Run `npx @hiveforge/hivemind-mcp validate` to check your setup.'));
}

/**
 * Output error for missing config.json.
 * Called when commands other than init are run without config.
 */
export function outputMissingConfigError(): void {
  console.error(error('config.json not found.'));
  console.error('\nRun `npx @hiveforge/hivemind-mcp init` to create one.');
  console.error('Or use: `npx @hiveforge/hivemind-mcp --vault <path>`');
}

/**
 * Output error for invalid vault path.
 */
export function outputInvalidVaultError(path: string): void {
  console.error(error(`Invalid vault path: ${path}`));
  console.error('\nThe path must be an existing directory.');
}
```
  </action>
  <verify>
File exists at src/cli/init/output.ts.
TypeScript compilation succeeds: npm run build
  </verify>
  <done>
output.ts exports generateConfig, generateClaudeDesktopSnippet, writeConfigFile, outputNextSteps.
Also exports outputMissingConfigError and outputInvalidVaultError for ERR-01 and ERR-02.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create init index with non-interactive mode</name>
  <files>src/cli/init/index.ts</files>
  <action>
Create src/cli/init/index.ts - main entry point combining all init modules:

```typescript
import { resolve, existsSync } from 'path';
import { readFileSync } from 'fs';
import { runInteractiveWizard } from './wizard.js';
import { validateVaultPath, validatePresetFile, configExists } from './validators.js';
import { generateConfig, writeConfigFile, outputNextSteps, outputInvalidVaultError } from './output.js';
import { success, error, dim } from '../shared/colors.js';

/**
 * Options for init command.
 */
export interface InitOptions {
  /** Path to preset config file (--config flag) */
  config?: string;
  /** Vault path (--vault flag) */
  vault?: string;
  /** Template ID (--template flag) */
  template?: string;
  /** Skip confirmations (--yes flag) */
  yes?: boolean;
}

/**
 * Parse init-specific arguments from process.argv.
 */
export function parseInitArgs(): InitOptions {
  const args = process.argv.slice(3); // Skip node, script, 'init'
  const options: InitOptions = {};

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    const next = args[i + 1];

    if (arg === '--config' && next) {
      options.config = next;
      i++;
    } else if (arg === '--vault' && next) {
      options.vault = next;
      i++;
    } else if (arg === '--template' && next) {
      options.template = next;
      i++;
    } else if (arg === '--yes' || arg === '-y') {
      options.yes = true;
    }
  }

  return options;
}

/**
 * Run init from preset file (--config flag).
 */
async function initFromPreset(presetPath: string): Promise<void> {
  console.log(dim(`Loading preset from: ${presetPath}\n`));

  const preset = validatePresetFile(presetPath);

  // Extract required fields
  const vaultPath = preset.vault?.path as string || preset.vaultPath as string;
  const templateId = preset.template?.activeTemplate as string || preset.templateId as string || 'worldbuilding';

  if (!vaultPath) {
    throw new Error('Preset must include vault.path or vaultPath');
  }

  // Validate vault path
  const validation = validateVaultPath(vaultPath);
  if (validation !== true) {
    throw new Error(validation);
  }

  // Generate and write config
  const resolvedVault = resolve(vaultPath);
  const config = generateConfig(resolvedVault, templateId);
  const configPath = writeConfigFile(process.cwd(), config);

  await outputNextSteps(resolvedVault, templateId, configPath, false);
}

/**
 * Run init from flags (--vault, --template).
 */
async function initFromFlags(options: InitOptions): Promise<void> {
  const vaultPath = options.vault!;
  const templateId = options.template || 'worldbuilding';

  // Validate vault path
  const validation = validateVaultPath(vaultPath);
  if (validation !== true) {
    outputInvalidVaultError(vaultPath);
    process.exit(1);
  }

  // Check for existing config
  if (configExists(process.cwd()) && !options.yes) {
    console.error(error('config.json already exists. Use --yes to overwrite.'));
    process.exit(1);
  }

  // Generate and write config
  const resolvedVault = resolve(vaultPath);
  const config = generateConfig(resolvedVault, templateId);
  const configPath = writeConfigFile(process.cwd(), config);

  await outputNextSteps(resolvedVault, templateId, configPath, false);
}

/**
 * Main init command entry point.
 *
 * Supports three modes:
 * 1. Interactive (default): Run wizard with prompts
 * 2. Preset file: --config preset.json
 * 3. Flags: --vault <path> --template <id>
 */
export async function initCommand(): Promise<void> {
  const options = parseInitArgs();

  try {
    // Mode 1: Preset file
    if (options.config) {
      await initFromPreset(options.config);
      return;
    }

    // Mode 2: Flags (vault required, template optional)
    if (options.vault) {
      await initFromFlags(options);
      return;
    }

    // Mode 3: Interactive wizard
    const result = await runInteractiveWizard();

    if (result.cancelled) {
      process.exit(0);
    }

    // Generate and write config
    const config = generateConfig(result.vaultPath, result.templateId);
    const configPath = writeConfigFile(process.cwd(), config);

    await outputNextSteps(result.vaultPath, result.templateId, configPath, true);

  } catch (err) {
    console.error(error(err instanceof Error ? err.message : String(err)));
    process.exit(1);
  }
}
```

This implements INIT-07: Non-interactive mode via --config and --vault/--template flags.
  </action>
  <verify>
File exists at src/cli/init/index.ts.
TypeScript compilation succeeds: npm run build
  </verify>
  <done>
index.ts exports initCommand as main entry point.
Supports three modes: interactive, --config preset, and --vault/--template flags.
Parses arguments and routes to appropriate handler.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update CLI to use new init command</name>
  <files>src/cli.ts</files>
  <action>
Update src/cli.ts to use the new init module, replacing the old readline-based init.

Key changes:
1. Import initCommand from './cli/init/index.js'
2. Replace the old init() function call with initCommand()
3. Update the fix() and start() functions to use outputMissingConfigError for ERR-01
4. Keep all other commands (validate, setup-mcp, etc.) unchanged

Find the init case in the switch statement:
```typescript
case 'init':
  init();
  break;
```

Replace with:
```typescript
case 'init':
  initCommand();
  break;
```

Also update the imports at the top of the file to add:
```typescript
import { initCommand } from './cli/init/index.js';
```

And import the error output helpers:
```typescript
import { outputMissingConfigError, outputInvalidVaultError } from './cli/init/output.js';
```

Update getVaultPath() error handling to use outputMissingConfigError for clearer messages (ERR-01).

The old init() function can be removed since it's replaced by the new module.

IMPORTANT: Keep all other CLI commands working (validate, fix, start, setup-mcp, template commands).
Only modify the init-related code paths.
  </action>
  <verify>
TypeScript compilation succeeds: npm run build
`npx hivemind init --help` or similar doesn't crash
Existing commands still work: npx hivemind validate, npx hivemind list-templates
  </verify>
  <done>
cli.ts imports and uses initCommand for the init command.
Old init() function removed.
Error messages use new output helpers for ERR-01 and ERR-02.
All existing commands continue to work.
  </done>
</task>

</tasks>

<verification>
1. npm run build - compiles without errors
2. All files exist: src/cli/init/output.ts, src/cli/init/index.ts
3. src/cli.ts updated to use initCommand
4. Run `node dist/cli.js --help` to verify CLI still works
5. Run `node dist/cli.js list-templates` to verify other commands work
</verification>

<success_criteria>
- output.ts created with config generation and Claude Desktop snippet
- index.ts created with interactive, preset, and flags modes
- cli.ts updated to use new initCommand
- Old init() function removed from cli.ts
- Non-interactive mode works with --config preset.json
- Non-interactive mode works with --vault and --template flags
- All existing CLI commands continue to work
- TypeScript build passes
</success_criteria>

<output>
After completion, create `.planning/phases/12-setup-wizard/12-03-SUMMARY.md`
</output>
