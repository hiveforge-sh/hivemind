---
phase: 07-migration
plan: 04
type: execute
wave: 3
depends_on: ["07-01", "07-02"]
files_modified:
  - src/server.ts
  - src/templates/loader.ts
autonomous: true

must_haves:
  truths:
    - "query_character and query_location call generic query_entity internally"
    - "Deprecated tools include deprecation warning in response metadata"
    - "Template auto-detection runs at server startup for vaults without config"
    - "Server logs which template was detected/loaded"
  artifacts:
    - path: "src/server.ts"
      provides: "Template-driven tool handlers"
      contains: "handleQueryEntity"
    - path: "src/server.ts"
      provides: "Deprecation warnings in tool responses"
      contains: "_meta"
  key_links:
    - from: "src/server.ts handleQueryCharacter"
      to: "src/server.ts handleQueryEntity"
      via: "internal delegation"
      pattern: "handleQueryEntity.*type.*character"
    - from: "src/server.ts start()"
      to: "src/templates/detector.ts"
      via: "template detection"
      pattern: "detectTemplate|TemplateDetector"
---

<objective>
Refactor MCP tools to use template system with deprecation warnings.

Purpose: Make query_character and query_location aliases to a generic query_entity that uses template registry for entity type resolution. Add deprecation warnings visible to AI/calling code.

Output:
- Generic handleQueryEntity method
- Deprecation wrappers for legacy tools
- Template auto-detection in server startup
- User notifications about detected template
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-migration/07-CONTEXT.md
@.planning/phases/07-migration/07-RESEARCH.md
@.planning/phases/07-migration/07-01-SUMMARY.md
@.planning/phases/07-migration/07-02-SUMMARY.md
@src/server.ts
@src/templates/detector.ts
@src/templates/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Generic handleQueryEntity Method</name>
  <files>
    src/server.ts
  </files>
  <action>
Add a new generic method that handles entity queries based on type:

```typescript
/**
 * Generic entity query handler.
 * This is the new implementation that query_character, query_location, etc. delegate to.
 */
private async handleQueryEntity(args: {
  type: string;
  id: string;
  includeContent?: boolean;
  contentLimit?: number;
}) {
  await this.ensureIndexed();

  // Use search engine to get node with relationships
  const result = await this.searchEngine.getNodeWithRelationships(args.id);

  if (!result || result.node.type !== args.type) {
    // Try fuzzy search within type
    const searchResults = await this.searchEngine.search(args.id, {
      limit: 5,
      filters: { type: [args.type] }
    });

    if (searchResults.nodes.length === 0) {
      return {
        content: [{
          type: 'text',
          text: `${this.capitalizeFirst(args.type)} not found: "${args.id}"\n\nTry searching with: search_vault`,
        }],
      };
    }

    // Return suggestions
    const suggestions = searchResults.nodes.map(n => `- ${n.title} (${n.id})`).join('\n');
    return {
      content: [{
        type: 'text',
        text: `${this.capitalizeFirst(args.type)} "${args.id}" not found. Did you mean:\n\n${suggestions}`,
      }],
    };
  }

  // Format response based on entity type
  // For now, use existing formatters. Later, template-driven formatting.
  const response = this.formatEntityWithRelationships(
    result,
    args.type,
    args.includeContent ?? true,
    args.contentLimit ?? 500
  );

  return {
    content: [{
      type: 'text',
      text: response,
    }],
  };
}

private capitalizeFirst(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generic entity formatter that handles any entity type.
 * Falls back to type-specific formatters for backwards compatibility.
 */
private formatEntityWithRelationships(
  result: any,
  entityType: string,
  includeContent: boolean,
  contentLimit: number
): string {
  // For backwards compatibility, use existing formatters for known types
  switch (entityType) {
    case 'character':
      return this.formatCharacterWithRelationships(result, includeContent, contentLimit);
    case 'location':
      return this.formatLocationWithRelationships(result, includeContent, contentLimit);
    default:
      // Generic formatter for other entity types
      return this.formatGenericEntity(result, entityType, includeContent, contentLimit);
  }
}

/**
 * Generic entity formatter for non-character, non-location types.
 */
private formatGenericEntity(
  result: any,
  entityType: string,
  includeContent: boolean,
  contentLimit: number
): string {
  const { node, relatedNodes } = result;
  const props = node.properties;

  let response = `# ${node.title}\n\n`;
  response += `**Type**: ${this.capitalizeFirst(entityType)} | **Status**: ${node.status} | **ID**: \`${node.id}\`\n\n`;

  // Show key properties
  for (const [key, value] of Object.entries(props)) {
    if (['id', 'type', 'status', 'title'].includes(key)) continue;
    if (value === null || value === undefined) continue;

    if (typeof value === 'object') {
      response += `**${this.capitalizeFirst(key)}**: ${JSON.stringify(value)}\n`;
    } else {
      response += `**${this.capitalizeFirst(key)}**: ${value}\n`;
    }
  }
  response += '\n';

  // Content (if requested)
  if (includeContent && node.content) {
    response += `## Content\n`;
    const content = node.content.trim();
    if (content.length > contentLimit) {
      response += `${content.substring(0, contentLimit)}...\n\n`;
      response += `*[Truncated at ${contentLimit} chars. Full content: ${content.length} chars]*\n\n`;
    } else {
      response += `${content}\n\n`;
    }
  }

  // Related entities
  if (relatedNodes.length > 0) {
    response += `## Related Entities\n`;
    const byType = new Map<string, any[]>();
    for (const related of relatedNodes) {
      const list = byType.get(related.type) || [];
      list.push(related);
      byType.set(related.type, list);
    }

    for (const [type, nodes] of byType) {
      response += `**${this.capitalizeFirst(type)}s**: ${nodes.map((n: any) => n.title).join(', ')}\n`;
    }
    response += '\n';
  }

  response += `---\n*Source: ${node.filePath}*\n`;
  response += `*Last updated: ${new Date(node.updated).toLocaleString()}*`;

  return response;
}
```
  </action>
  <verify>
Run `npm run build` - no TypeScript errors.
  </verify>
  <done>
Generic handleQueryEntity and formatEntityWithRelationships methods added.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor Legacy Tools as Deprecation Wrappers</name>
  <files>
    src/server.ts
  </files>
  <action>
Modify handleQueryCharacter and handleQueryLocation to delegate to handleQueryEntity with deprecation metadata:

```typescript
private async handleQueryCharacter(args: { id: string; includeContent?: boolean; contentLimit?: number }) {
  // Delegate to generic handler
  const response = await this.handleQueryEntity({
    type: 'character',
    ...args
  });

  // Add deprecation metadata
  // Note: MCP SDK may not have native deprecation support, so we add it to response
  return {
    ...response,
    _meta: {
      deprecated: true,
      deprecationMessage: 'query_character is deprecated. Use query_entity with type="character" instead. Removal planned for v3.0.0.',
      sunset: '2027-01-01',
      replacement: 'query_entity',
    },
  };
}

private async handleQueryLocation(args: { id: string; includeContent?: boolean; contentLimit?: number }) {
  // Delegate to generic handler
  const response = await this.handleQueryEntity({
    type: 'location',
    ...args
  });

  // Add deprecation metadata
  return {
    ...response,
    _meta: {
      deprecated: true,
      deprecationMessage: 'query_location is deprecated. Use query_entity with type="location" instead. Removal planned for v3.0.0.',
      sunset: '2027-01-01',
      replacement: 'query_entity',
    },
  };
}
```

Also update the tool listing to mark these as deprecated:

In the ListToolsRequestSchema handler, update descriptions:
```typescript
{
  name: 'query_character',
  description: '[DEPRECATED - use query_entity] Retrieve detailed information about a character from the worldbuilding vault',
  // ... rest of schema
},
{
  name: 'query_location',
  description: '[DEPRECATED - use query_entity] Retrieve information about a location from the worldbuilding vault',
  // ... rest of schema
},
```

Add query_entity as a new tool:
```typescript
{
  name: 'query_entity',
  description: 'Retrieve detailed information about any entity from the vault by type and ID',
  inputSchema: {
    type: 'object',
    properties: {
      type: {
        type: 'string',
        description: 'Entity type (e.g., character, location, event, faction, lore)',
      },
      id: {
        type: 'string',
        description: 'Entity ID or name to query',
      },
      includeContent: {
        type: 'boolean',
        description: 'Include content body in response (default: true)',
        default: true,
      },
      contentLimit: {
        type: 'number',
        description: 'Maximum characters of content to return (default: 500, max: 5000)',
        default: 500,
        minimum: 100,
        maximum: 5000,
      },
    },
    required: ['type', 'id'],
  },
},
```

Add case in CallToolRequestSchema handler:
```typescript
case 'query_entity': {
  const parsed = z.object({
    type: z.string(),
    id: z.string(),
    includeContent: z.boolean().optional().default(true),
    contentLimit: z.number().min(100).max(5000).optional().default(500),
  }).parse(args);
  return await this.handleQueryEntity(parsed);
}
```
  </action>
  <verify>
Run `npm run build` - no errors.
Run `npm test` - all tests pass.
  </verify>
  <done>
Legacy tools delegate to query_entity. Deprecation warnings in metadata. New query_entity tool available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Template Detection at Startup</name>
  <files>
    src/server.ts
    src/templates/loader.ts
  </files>
  <action>
Update server startup to use template detection when no config exists.

Modify src/server.ts start() method:

```typescript
import { TemplateDetector } from './templates/index.js';
// ... existing imports

async start(): Promise<void> {
  // Template detection and initialization
  console.error('[Server] Initializing template system...');

  try {
    // Check for explicit config first
    const configPath = join(this.config.vault.path, 'hivemind.config.json');
    let detectedTemplate: string | undefined;

    if (!existsSync(configPath)) {
      // Auto-detect template from vault structure
      const detector = new TemplateDetector();
      const detection = await detector.detectTemplate(this.config.vault.path);

      if (detection) {
        detectedTemplate = detection.templateId;
        console.error(`[Server] ${detection.message}`);

        // Store detected template in database for persistence
        this.database.setActiveTemplate(detection.templateId);
      } else {
        console.error('[Server] Could not detect template from vault structure. Using default: worldbuilding');
        detectedTemplate = 'worldbuilding';
        this.database.setActiveTemplate('worldbuilding');
      }
    }

    // Initialize template system (loads config or uses detected template)
    this.templateConfig = initializeTemplates(detectedTemplate);
    console.error(`[Server] Template system initialized: ${this.templateConfig.activeTemplate}`);

    // Update graph builder with active template
    this.graphBuilder.setTemplateId(this.templateConfig.activeTemplate);

  } catch (err) {
    console.error('[Server] Warning: Template initialization failed:', err);
    // Continue without templates for backwards compatibility
  }

  // ... rest of existing start() code (vault scan, etc.)
}
```

Update src/templates/loader.ts to accept optional template override:

```typescript
/**
 * Initialize the template system.
 *
 * @param templateOverride - Optional template ID to use instead of config
 * @returns The template configuration
 */
export function initializeTemplates(templateOverride?: string): TemplateConfig {
  // 1. Register built-in templates
  registerBuiltinTemplate(worldbuildingTemplate);

  // 2. Load user config (or use defaults)
  const config = loadTemplateConfig();

  // 3. Determine active template
  const activeTemplateId = templateOverride || config.activeTemplate;

  // 4. Activate the template
  const activeTemplate = activateTemplate(activeTemplateId);

  // 5. Pre-generate schemas
  pregenerateSchemas();

  return {
    activeTemplate: activeTemplateId,
    templates: [activeTemplate],
    config,
  };
}
```

Add import for existsSync:
```typescript
import { existsSync } from 'fs';
```
  </action>
  <verify>
Run `npm run build` - no errors.
Test manually: Start server with vault that has Characters/ folder - should detect worldbuilding template.
  </verify>
  <done>
Template auto-detection runs at startup. User sees which template was detected. Template persisted to database.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm test` passes all tests including snapshot tests (no format changes)
3. query_character and query_location return _meta.deprecated = true
4. New query_entity tool works for any entity type
5. Server startup logs show template detection
6. Without config, worldbuilding template auto-detected from Characters/Locations folders
</verification>

<success_criteria>
- [ ] handleQueryEntity method handles any entity type
- [ ] formatEntityWithRelationships falls back to type-specific formatters
- [ ] formatGenericEntity works for non-character/location types
- [ ] query_character delegates to handleQueryEntity
- [ ] query_location delegates to handleQueryEntity
- [ ] Response includes _meta.deprecated with deprecation message
- [ ] Tool listing shows [DEPRECATED] in description
- [ ] New query_entity tool listed and functional
- [ ] TemplateDetector used at startup when no config
- [ ] initializeTemplates accepts templateOverride parameter
- [ ] Detected template logged to console
- [ ] Detected template stored in database metadata
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration/07-04-SUMMARY.md`
</output>
