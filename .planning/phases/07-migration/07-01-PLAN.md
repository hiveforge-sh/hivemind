---
phase: 07-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/templates/detector.ts
  - src/graph/database.ts
  - tests/templates/detector.test.ts
autonomous: true

must_haves:
  truths:
    - "Template auto-detection identifies worldbuilding vaults from folder structure"
    - "Database stores schema version and active template in metadata table"
    - "Detection notifies user which template was detected"
  artifacts:
    - path: "src/templates/detector.ts"
      provides: "Template detection from vault folder structure"
      exports: ["TemplateDetector", "DetectionResult"]
    - path: "src/graph/database.ts"
      provides: "Metadata table for versioning"
      contains: "CREATE TABLE IF NOT EXISTS metadata"
  key_links:
    - from: "src/templates/detector.ts"
      to: "fs.promises.readdir"
      via: "folder scanning"
      pattern: "readdir.*withFileTypes"
    - from: "src/graph/database.ts"
      to: "metadata table"
      via: "getMetadata/setMetadata methods"
      pattern: "SELECT.*FROM metadata"
---

<objective>
Create template auto-detection and database metadata infrastructure.

Purpose: Enable automatic template identification from vault structure for backwards compatibility with existing worldbuilding vaults. Add database versioning to support schema evolution.

Output:
- TemplateDetector class that scans vault folders and matches against template patterns
- Database metadata table for storing schema_version and active_template
- Unit tests for detection logic
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-migration/07-CONTEXT.md
@.planning/phases/07-migration/07-RESEARCH.md
@src/templates/types.ts
@src/templates/registry.ts
@src/graph/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Template Detector</name>
  <files>
    src/templates/detector.ts
    tests/templates/detector.test.ts
  </files>
  <action>
Create TemplateDetector class with the following structure:

```typescript
// src/templates/detector.ts
import { promises as fs } from 'fs';
import { join } from 'path';

export interface DetectionResult {
  templateId: string;
  confidence: 'high' | 'medium' | 'low';
  matchedPatterns: string[];
  message: string;  // User-friendly notification message
}

export class TemplateDetector {
  // Worldbuilding folder patterns (case-insensitive)
  private static readonly WORLDBUILDING_PATTERNS = [
    'characters', 'character',
    'locations', 'location',
    'events', 'event',
    'factions', 'faction',
    'lore',
    'assets', 'asset'
  ];

  /**
   * Detect template from vault folder structure.
   * Returns null if no template can be detected.
   */
  async detectTemplate(vaultPath: string): Promise<DetectionResult | null> {
    const folders = await this.listTopLevelFolders(vaultPath);

    // Check for worldbuilding patterns
    const matched = folders.filter(f =>
      TemplateDetector.WORLDBUILDING_PATTERNS.some(p =>
        f.toLowerCase().includes(p.toLowerCase())
      )
    );

    if (matched.length >= 2) {
      const confidence = matched.length >= 4 ? 'high' : matched.length >= 3 ? 'medium' : 'low';
      return {
        templateId: 'worldbuilding',
        confidence,
        matchedPatterns: matched,
        message: `Detected worldbuilding vault (${confidence} confidence). Matched folders: ${matched.join(', ')}`
      };
    }

    return null;
  }

  private async listTopLevelFolders(vaultPath: string): Promise<string[]> {
    const entries = await fs.readdir(vaultPath, { withFileTypes: true });
    return entries
      .filter(e => e.isDirectory())
      .filter(e => !e.name.startsWith('.'))
      .map(e => e.name);
  }
}
```

Tests should cover:
- High confidence detection (4+ matching folders)
- Medium confidence detection (3 matching folders)
- Low confidence detection (2 matching folders)
- No detection (< 2 matching folders)
- Case-insensitive matching
- Ignores hidden folders (.git, .obsidian, etc.)

Use vitest with mock filesystem (memfs or simple mocking).
  </action>
  <verify>
Run `npm test tests/templates/detector.test.ts` - all tests pass.
  </verify>
  <done>
TemplateDetector correctly identifies worldbuilding vaults with appropriate confidence levels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Database Metadata Table</name>
  <files>
    src/graph/database.ts
  </files>
  <action>
Extend HivemindDatabase class with metadata table support:

1. Add metadata table creation in initializeSchema():
```sql
CREATE TABLE IF NOT EXISTS metadata (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL,
  updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
);
```

2. Add helper methods:
```typescript
/**
 * Get a metadata value by key
 */
getMetadata(key: string): string | null {
  const row = this.db.prepare('SELECT value FROM metadata WHERE key = ?').get(key) as { value: string } | undefined;
  return row?.value ?? null;
}

/**
 * Set a metadata value
 */
setMetadata(key: string, value: string): void {
  this.db.prepare(`
    INSERT INTO metadata (key, value, updated_at)
    VALUES (?, ?, strftime('%s', 'now'))
    ON CONFLICT(key) DO UPDATE SET
      value = excluded.value,
      updated_at = strftime('%s', 'now')
  `).run(key, value);
}

/**
 * Get current schema version
 */
getSchemaVersion(): string | null {
  return this.getMetadata('schema_version');
}

/**
 * Get active template ID
 */
getActiveTemplate(): string | null {
  return this.getMetadata('active_template');
}

/**
 * Set active template
 */
setActiveTemplate(templateId: string): void {
  this.setMetadata('active_template', templateId);
}
```

3. In initializeSchema(), after creating metadata table, set default schema version if not exists:
```typescript
const schemaVersion = this.getMetadata('schema_version');
if (!schemaVersion) {
  this.setMetadata('schema_version', '2.0.0');
}
```

Do NOT add template_id column yet - that's Plan 02.
  </action>
  <verify>
Run `npm test` - all 127+ existing tests still pass. Build with `npm run build` - no TypeScript errors.
  </verify>
  <done>
Database has metadata table with getMetadata/setMetadata methods. Schema version tracked. Active template storage ready.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export Detector and Update Index</name>
  <files>
    src/templates/index.ts
  </files>
  <action>
Add detector export to src/templates/index.ts:

```typescript
export * from './detector.js';
```

This makes TemplateDetector available to consumers via the templates module.
  </action>
  <verify>
Run `npm run build` - successful. Check dist/templates/index.js exports detector.
  </verify>
  <done>
TemplateDetector exported from templates module, ready for use in server startup.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds without errors
2. `npm test` passes all existing tests + new detector tests
3. Database creates metadata table on initialization
4. TemplateDetector correctly identifies worldbuilding folder patterns
</verification>

<success_criteria>
- [ ] TemplateDetector class exists with detectTemplate(vaultPath) method
- [ ] Detection returns confidence levels (high/medium/low) based on match count
- [ ] Detection returns user-friendly message for notification
- [ ] Database has metadata table with key/value/updated_at columns
- [ ] getMetadata/setMetadata/getSchemaVersion/getActiveTemplate methods work
- [ ] All existing tests pass (no regressions)
- [ ] Detector tests cover all confidence levels
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration/07-01-SUMMARY.md`
</output>
