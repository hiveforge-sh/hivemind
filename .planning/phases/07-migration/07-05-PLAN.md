---
phase: 07-migration
plan: 05
type: execute
wave: 4
depends_on: ["07-04"]
files_modified:
  - tests/migration/parity.test.ts
  - tests/templates/integration.test.ts
  - tests/integration/vault-graph-search.test.ts
autonomous: false

must_haves:
  truths:
    - "Snapshot tests pass after migration (v1.0 parity maintained)"
    - "All existing tests pass with template system"
    - "Test suite validates template-driven behavior"
    - "Backwards compatibility verified with existing vault structure"
    - "Worldbuilding template contains ALL v1.0 entity types with ALL their fields"
  artifacts:
    - path: "tests/templates/integration.test.ts"
      provides: "Template system integration tests"
      contains: "detectTemplate"
    - path: "tests/migration/parity.test.ts"
      provides: "Updated snapshot tests"
      contains: "query_entity"
  key_links:
    - from: "tests/templates/integration.test.ts"
      to: "src/templates/detector.ts"
      via: "integration test"
      pattern: "TemplateDetector.*detectTemplate"
    - from: "tests/templates/integration.test.ts"
      to: "src/templates/builtin/worldbuilding.ts"
      via: "v1.0 field enumeration"
      pattern: "V1_ENTITY_FIELDS"
---

<objective>
Verify migration parity and update test suite for template system.

Purpose: Ensure all existing tests pass with the refactored template system. Verify snapshot tests confirm v1.0 parity. Add integration tests for template detection and loading. CRITICALLY: Verify that the worldbuilding template contains ALL v1.0 entity types with ALL their fields before migrating away from hardcoded logic.

Output:
- Verified snapshot test parity (no unexpected changes)
- Updated test suite testing template-driven behavior
- Integration tests for template detection
- Explicit v1.0 field coverage verification tests
- Human verification of backwards compatibility
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-migration/07-CONTEXT.md
@.planning/phases/07-migration/07-04-SUMMARY.md
@tests/migration/parity.test.ts
@tests/integration/vault-graph-search.test.ts
@src/templates/builtin/worldbuilding.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run Snapshot Tests and Update if Needed</name>
  <files>
    tests/migration/parity.test.ts
    tests/migration/__snapshots__/parity.test.ts.snap
  </files>
  <action>
Run the snapshot tests after migration changes:

```bash
npm test tests/migration/parity.test.ts
```

Expected outcomes:
1. **Tests pass**: The response format is identical to v1.0. Migration successful.
2. **Tests fail with expected diffs**: Some changes are intentional (e.g., _meta field added to deprecated tools)

If tests fail, review the diffs:
- If only `_meta` field added: This is expected, update snapshots
- If response format changed: Investigate and fix to maintain parity
- If content differences: May indicate bug in migration

To update snapshots for intentional changes:
```bash
npm test tests/migration/parity.test.ts -- --update
```

Add test for new query_entity tool to parity.test.ts:

```typescript
describe('query_entity (new tool)', () => {
  it('returns expected format for character', async () => {
    const response = await callTool(server, 'query_entity', {
      type: 'character',
      id: 'alice',
      includeContent: true,
      contentLimit: 500,
    });

    // Should match query_character format (minus deprecation warning)
    const normalized = normalizeResponse(response);
    expect(normalized).toMatchSnapshot();
  });

  it('returns expected format for location', async () => {
    const response = await callTool(server, 'query_entity', {
      type: 'location',
      id: 'tavern',
      includeContent: true,
      contentLimit: 500,
    });

    const normalized = normalizeResponse(response);
    expect(normalized).toMatchSnapshot();
  });

  it('returns expected format for event', async () => {
    const response = await callTool(server, 'query_entity', {
      type: 'event',
      id: 'battle-ironhold',
      includeContent: true,
      contentLimit: 500,
    });

    const normalized = normalizeResponse(response);
    expect(normalized).toMatchSnapshot();
  });
});
```

Update callTool helper to handle query_entity:
```typescript
case 'query_entity':
  // @ts-expect-error - private method
  return server.handleQueryEntity(args);
```
  </action>
  <verify>
Run `npm test tests/migration/parity.test.ts` - all tests pass.
Review snapshot diffs if any to ensure changes are intentional.
  </verify>
  <done>
Snapshot tests pass. v1.0 parity maintained. New query_entity snapshots created.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Template Integration Tests with v1.0 Field Coverage (MIGR-01)</name>
  <files>
    tests/templates/integration.test.ts
  </files>
  <action>
Create integration tests for template detection, system startup, AND explicit verification that worldbuilding template contains ALL v1.0 entity types with ALL their fields.

This is critical for MIGR-01: Before migrating away from hardcoded logic, we must verify the template has complete coverage.

```typescript
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { TemplateDetector } from '../../src/templates/detector.js';
import { initializeTemplates, getActiveTemplate, getEntityType } from '../../src/templates/index.js';
import { promises as fs } from 'fs';
import { join } from 'path';
import { tmpdir } from 'os';

/**
 * v1.0 Entity Field Reference
 *
 * This is the definitive list of ALL fields from the hardcoded v1.0 schemas.
 * These tests verify the worldbuilding template contains ALL these fields
 * BEFORE we can safely migrate away from hardcoded logic.
 *
 * Source: Original src/types/index.ts hardcoded schemas
 */
const V1_ENTITY_FIELDS = {
  character: [
    'name',        // required
    'age',
    'gender',
    'race',
    'appearance',  // record type
    'personality', // record type
    'relationships', // array of records
    'assets',      // array of strings
  ],
  location: [
    'name',        // required
    'region',
    'category',
    'parent',
    'hierarchy_level', // enum
    'children',    // array
    'climate',
    'terrain',     // array
    'inhabitants', // array
    'connections', // array of records
    'assets',      // array
  ],
  event: [
    'name',        // required
    'date',
    'date_start',
    'date_end',
    'date_display',
    'event_type',
    'participants', // array
    'locations',    // array
    'factions',     // array
    'outcome',
    'consequences', // array
    'timeline',
    'previous_event',
    'next_event',
  ],
  faction: [
    'name',        // required
    'faction_type', // enum
    'leader',
    'members',     // array
    'headquarters',
    'founded',
    'goals',       // array
    'resources',   // array
    'allies',      // array
    'rivals',      // array
  ],
  lore: [
    'name',        // required
    'category',    // enum
    'related_entities', // array
    'source',      // enum
  ],
  asset: [
    'asset_type',  // enum, default 'image'
    'file_path',   // required
    'file_format',
    'depicts',     // array
    'generation_date',
    'generator',
    'workflow_id',
    'prompt',
    'parameters',  // record
  ],
};

describe('Template System Integration', () => {
  describe('TemplateDetector', () => {
    let tempDir: string;

    beforeAll(async () => {
      tempDir = join(tmpdir(), `hivemind-test-${Date.now()}`);
      await fs.mkdir(tempDir, { recursive: true });
    });

    afterAll(async () => {
      await fs.rm(tempDir, { recursive: true, force: true });
    });

    it('detects worldbuilding template with high confidence', async () => {
      // Create worldbuilding-like structure
      await fs.mkdir(join(tempDir, 'Characters'), { recursive: true });
      await fs.mkdir(join(tempDir, 'Locations'), { recursive: true });
      await fs.mkdir(join(tempDir, 'Events'), { recursive: true });
      await fs.mkdir(join(tempDir, 'Factions'), { recursive: true });

      const detector = new TemplateDetector();
      const result = await detector.detectTemplate(tempDir);

      expect(result).not.toBeNull();
      expect(result!.templateId).toBe('worldbuilding');
      expect(result!.confidence).toBe('high');
      expect(result!.matchedPatterns).toContain('Characters');
      expect(result!.matchedPatterns).toContain('Locations');
    });

    it('detects worldbuilding template with medium confidence', async () => {
      const mediumDir = join(tempDir, 'medium');
      await fs.mkdir(join(mediumDir, 'characters'), { recursive: true });
      await fs.mkdir(join(mediumDir, 'locations'), { recursive: true });
      await fs.mkdir(join(mediumDir, 'notes'), { recursive: true });

      const detector = new TemplateDetector();
      const result = await detector.detectTemplate(mediumDir);

      expect(result).not.toBeNull();
      expect(result!.templateId).toBe('worldbuilding');
      expect(result!.confidence).toBe('low'); // Only 2 matches
    });

    it('returns null for non-matching vault', async () => {
      const emptyDir = join(tempDir, 'empty');
      await fs.mkdir(emptyDir, { recursive: true });
      await fs.mkdir(join(emptyDir, 'random-folder'), { recursive: true });

      const detector = new TemplateDetector();
      const result = await detector.detectTemplate(emptyDir);

      expect(result).toBeNull();
    });

    it('ignores hidden folders', async () => {
      const hiddenDir = join(tempDir, 'hidden-test');
      await fs.mkdir(join(hiddenDir, '.characters'), { recursive: true });
      await fs.mkdir(join(hiddenDir, '.locations'), { recursive: true });
      await fs.mkdir(join(hiddenDir, 'notes'), { recursive: true });

      const detector = new TemplateDetector();
      const result = await detector.detectTemplate(hiddenDir);

      // Should not match hidden folders
      expect(result).toBeNull();
    });
  });

  describe('Template System Initialization', () => {
    it('initializes with worldbuilding template by default', () => {
      const config = initializeTemplates();

      expect(config.activeTemplate).toBe('worldbuilding');
    });

    it('accepts template override', () => {
      const config = initializeTemplates('worldbuilding');

      expect(config.activeTemplate).toBe('worldbuilding');
    });

    it('provides entity type lookups', () => {
      initializeTemplates();

      const character = getEntityType('character');
      expect(character).not.toBeNull();
      expect(character?.name).toBe('character');
      expect(character?.displayName).toBe('Character');

      const location = getEntityType('location');
      expect(location).not.toBeNull();
      expect(location?.name).toBe('location');
    });

    it('returns null for unknown entity types', () => {
      initializeTemplates();

      const unknown = getEntityType('unknown-type');
      expect(unknown).toBeNull();
    });
  });

  /**
   * MIGR-01: v1.0 Backwards Compatibility Field Coverage
   *
   * These tests are CRITICAL for migration safety. They verify that the
   * worldbuilding template contains EVERY field from the v1.0 hardcoded
   * schemas. If any test fails, the migration is NOT safe.
   */
  describe('Backwards Compatibility: v1.0 Field Coverage (MIGR-01)', () => {
    beforeAll(() => {
      initializeTemplates();
    });

    it('worldbuilding template has all v1.0 entity types', () => {
      const v1Types = Object.keys(V1_ENTITY_FIELDS);

      for (const typeName of v1Types) {
        const entityType = getEntityType(typeName);
        expect(entityType, `MIGRATION BLOCKER: Missing v1.0 entity type: ${typeName}`).not.toBeNull();
      }
    });

    it('character entity type has ALL v1.0 fields', () => {
      const character = getEntityType('character');
      expect(character).not.toBeNull();

      const fieldNames = character!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.character;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: character missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('location entity type has ALL v1.0 fields', () => {
      const location = getEntityType('location');
      expect(location).not.toBeNull();

      const fieldNames = location!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.location;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: location missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('event entity type has ALL v1.0 fields', () => {
      const event = getEntityType('event');
      expect(event).not.toBeNull();

      const fieldNames = event!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.event;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: event missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('faction entity type has ALL v1.0 fields', () => {
      const faction = getEntityType('faction');
      expect(faction).not.toBeNull();

      const fieldNames = faction!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.faction;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: faction missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('lore entity type has ALL v1.0 fields', () => {
      const lore = getEntityType('lore');
      expect(lore).not.toBeNull();

      const fieldNames = lore!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.lore;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: lore missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('asset entity type has ALL v1.0 fields', () => {
      const asset = getEntityType('asset');
      expect(asset).not.toBeNull();

      const fieldNames = asset!.fields.map(f => f.name);
      const expectedFields = V1_ENTITY_FIELDS.asset;

      for (const field of expectedFields) {
        expect(fieldNames, `MIGRATION BLOCKER: asset missing v1.0 field: ${field}`).toContain(field);
      }
    });

    it('summary: all v1.0 entity types have complete field coverage', () => {
      // This is a rollup test that provides a clear pass/fail for MIGR-01
      const issues: string[] = [];

      for (const [typeName, expectedFields] of Object.entries(V1_ENTITY_FIELDS)) {
        const entityType = getEntityType(typeName);

        if (!entityType) {
          issues.push(`Missing entity type: ${typeName}`);
          continue;
        }

        const actualFields = entityType.fields.map(f => f.name);
        const missingFields = expectedFields.filter(f => !actualFields.includes(f));

        if (missingFields.length > 0) {
          issues.push(`${typeName} missing fields: ${missingFields.join(', ')}`);
        }
      }

      if (issues.length > 0) {
        throw new Error(
          `MIGR-01 FAILED: Worldbuilding template does not have complete v1.0 field coverage.\n\n` +
          `Issues found:\n${issues.map(i => `  - ${i}`).join('\n')}\n\n` +
          `The migration CANNOT proceed until all v1.0 fields are present in the template.`
        );
      }

      // If we get here, all fields are present
      expect(issues).toHaveLength(0);
    });
  });
});
```
  </action>
  <verify>
Run `npm test tests/templates/integration.test.ts` - all tests pass.
CRITICAL: The "v1.0 Field Coverage" tests MUST pass before migration can proceed.
  </verify>
  <done>
Template integration tests verify detection, initialization, and COMPLETE v1.0 field coverage. MIGR-01 requirement satisfied with explicit enumeration of all v1.0 fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run Full Test Suite</name>
  <files>
    (all test files)
  </files>
  <action>
Run the complete test suite to verify no regressions:

```bash
npm test
```

Expected: All tests pass (should be ~130+ tests now).

If any tests fail:
1. Identify the failure
2. Determine if it's due to migration changes or pre-existing issue
3. Fix the issue while maintaining backwards compatibility

Common issues to watch for:
- Tests that mock database schema may need updating for template_id
- Tests that check exact response format may need updating for _meta field
- GraphBuilder tests may need updating for templateId parameter

After all tests pass, verify the build:
```bash
npm run build
```
  </action>
  <verify>
`npm test` shows all tests passing.
`npm run build` succeeds with no errors.
  </verify>
  <done>
Full test suite passes. Build succeeds. No regressions from migration.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Template system migration complete:
- Template auto-detection from vault folder structure
- Database schema with template_id and metadata table
- Refactored MCP tools with deprecation warnings
- Generic query_entity tool
- Snapshot tests for v1.0 parity
- Template integration tests with EXPLICIT v1.0 field coverage verification (MIGR-01)
  </what-built>
  <how-to-verify>
1. Start the MCP server with an existing worldbuilding vault:
   ```bash
   cd your-vault-path
   npx hivemind
   ```

2. Check startup logs show template detection:
   - Should see: "[Server] Detected worldbuilding vault (high/medium confidence)"
   - Should see: "[Server] Template system initialized: worldbuilding"

3. Test query_character in Claude/Cline:
   - Query an existing character
   - Response should look the same as before
   - Response should include deprecation note (may be hidden in metadata)

4. Test new query_entity tool:
   - Query with type="character" and id="your-character"
   - Should return same format as query_character

5. Verify existing vault works unchanged:
   - All MCP tools still function
   - No errors or missing data
   - Relationships still work

6. Check database:
   - Look in .hivemind/vault.db
   - nodes table should have template_id column
   - metadata table should exist with schema_version and active_template

7. Verify MIGR-01 test coverage:
   - Run `npm test tests/templates/integration.test.ts`
   - All "v1.0 Field Coverage" tests should pass
   - This confirms worldbuilding template has ALL v1.0 fields
  </how-to-verify>
  <resume-signal>Type "approved" if backwards compatibility verified, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
1. All snapshot tests pass (v1.0 parity maintained)
2. All template integration tests pass
3. v1.0 field coverage tests pass (MIGR-01 satisfied)
4. Full test suite passes (~130+ tests)
5. Build succeeds
6. Human verification confirms backwards compatibility
</verification>

<success_criteria>
- [ ] Snapshot tests pass without unexpected changes
- [ ] query_entity snapshots created for character, location, event
- [ ] Template detection integration tests pass
- [ ] v1.0 field coverage tests enumerate ALL fields for ALL entity types
- [ ] All v1.0 entity types present: character, location, event, faction, lore, asset
- [ ] character has: name, age, gender, race, appearance, personality, relationships, assets
- [ ] location has: name, region, category, parent, hierarchy_level, children, climate, terrain, inhabitants, connections, assets
- [ ] event has: name, date, date_start, date_end, date_display, event_type, participants, locations, factions, outcome, consequences, timeline, previous_event, next_event
- [ ] faction has: name, faction_type, leader, members, headquarters, founded, goals, resources, allies, rivals
- [ ] lore has: name, category, related_entities, source
- [ ] asset has: asset_type, file_path, file_format, depicts, generation_date, generator, workflow_id, prompt, parameters
- [ ] Full test suite passes
- [ ] Build succeeds
- [ ] Human verified: existing vault works unchanged
- [ ] Human verified: startup shows template detection
- [ ] Human verified: deprecated tools work with deprecation metadata
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration/07-05-SUMMARY.md`
</output>
