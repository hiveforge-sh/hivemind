---
phase: 07-migration
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/graph/database.ts
  - src/graph/builder.ts
  - tests/graph/builder.test.ts
autonomous: true

must_haves:
  truths:
    - "System can track which template each entity belongs to"
    - "Schema mismatch triggers automatic rebuild from markdown"
    - "Graph builder stores template_id when inserting nodes"
  artifacts:
    - path: "src/graph/database.ts"
      provides: "Template-aware database schema"
      contains: "template_id TEXT"
    - path: "src/graph/builder.ts"
      provides: "Template-aware node insertion"
      contains: "templateId"
  key_links:
    - from: "src/graph/builder.ts"
      to: "src/graph/database.ts"
      via: "upsertNode with templateId"
      pattern: "upsertNode.*template"
---

<objective>
Add template_id column to nodes table and implement schema migration via rebuild.

Purpose: Support multiple templates in same database by tagging each node with its template. Enable automatic database rebuild when schema version changes.

Output:
- Nodes table with template_id column (default: 'worldbuilding')
- Schema version checking on startup
- Auto-rebuild mechanism when schema mismatch detected
- GraphBuilder passes templateId when inserting nodes
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-migration/07-CONTEXT.md
@.planning/phases/07-migration/07-RESEARCH.md
@.planning/phases/07-migration/07-01-SUMMARY.md
@src/graph/database.ts
@src/graph/builder.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add template_id Column to Nodes Table</name>
  <files>
    src/graph/database.ts
  </files>
  <action>
Modify the nodes table schema in initializeSchema() to include template_id:

1. Update the CREATE TABLE statement for nodes:
```sql
CREATE TABLE IF NOT EXISTS nodes (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  status TEXT NOT NULL,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  frontmatter TEXT NOT NULL,
  file_path TEXT NOT NULL,
  template_id TEXT NOT NULL DEFAULT 'worldbuilding',
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);
```

2. Add index for template_id:
```sql
CREATE INDEX IF NOT EXISTS idx_nodes_template ON nodes(template_id);
```

3. Since SQLite doesn't support ADD COLUMN with constraints easily, implement schema migration via table check:

```typescript
private initializeSchema(): void {
  // Create metadata table first (from Plan 01)
  this.db.exec(`
    CREATE TABLE IF NOT EXISTS metadata (
      key TEXT PRIMARY KEY,
      value TEXT NOT NULL,
      updated_at INTEGER NOT NULL DEFAULT (strftime('%s', 'now'))
    );
  `);

  // Check schema version
  const currentVersion = this.getMetadata('schema_version');
  const targetVersion = '2.0.0';

  // Check if nodes table has template_id column
  const tableInfo = this.db.prepare("PRAGMA table_info(nodes)").all() as Array<{name: string}>;
  const hasTemplateId = tableInfo.some(col => col.name === 'template_id');

  if (currentVersion !== targetVersion || !hasTemplateId) {
    console.error(`[Database] Schema migration needed: ${currentVersion || 'none'} -> ${targetVersion}`);
    this.migrateSchema(targetVersion);
  }

  // ... rest of schema initialization
}

private migrateSchema(targetVersion: string): void {
  console.error('[Database] Migrating schema - will rebuild from vault on next scan');

  // Drop and recreate tables with new schema
  // This is safe because markdown is source of truth
  this.db.exec('DROP TABLE IF EXISTS nodes_fts');
  this.db.exec('DROP TABLE IF EXISTS relationships');
  this.db.exec('DROP TABLE IF EXISTS nodes');

  // Create nodes with template_id
  this.db.exec(`
    CREATE TABLE nodes (
      id TEXT PRIMARY KEY,
      type TEXT NOT NULL,
      status TEXT NOT NULL,
      title TEXT NOT NULL,
      content TEXT NOT NULL,
      frontmatter TEXT NOT NULL,
      file_path TEXT NOT NULL,
      template_id TEXT NOT NULL DEFAULT 'worldbuilding',
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    );
  `);

  // Recreate relationships table
  this.db.exec(`
    CREATE TABLE relationships (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      source_id TEXT NOT NULL,
      target_id TEXT NOT NULL,
      rel_type TEXT,
      properties TEXT,
      FOREIGN KEY (source_id) REFERENCES nodes(id) ON DELETE CASCADE,
      FOREIGN KEY (target_id) REFERENCES nodes(id) ON DELETE CASCADE,
      UNIQUE(source_id, target_id, rel_type)
    );
  `);

  // Recreate indexes
  this.db.exec(`
    CREATE INDEX idx_nodes_type ON nodes(type);
    CREATE INDEX idx_nodes_status ON nodes(status);
    CREATE INDEX idx_nodes_template ON nodes(template_id);
    CREATE INDEX idx_relationships_source ON relationships(source_id);
    CREATE INDEX idx_relationships_target ON relationships(target_id);
  `);

  // Recreate FTS table and triggers
  this.db.exec(`
    CREATE VIRTUAL TABLE nodes_fts USING fts5(
      id UNINDEXED,
      title,
      content,
      content='nodes',
      content_rowid='rowid'
    );
  `);

  this.db.exec(`
    CREATE TRIGGER nodes_ai AFTER INSERT ON nodes BEGIN
      INSERT INTO nodes_fts(rowid, id, title, content)
      VALUES (new.rowid, new.id, new.title, new.content);
    END;

    CREATE TRIGGER nodes_ad AFTER DELETE ON nodes BEGIN
      DELETE FROM nodes_fts WHERE rowid = old.rowid;
    END;

    CREATE TRIGGER nodes_au AFTER UPDATE ON nodes BEGIN
      UPDATE nodes_fts
      SET title = new.title, content = new.content
      WHERE rowid = new.rowid;
    END;
  `);

  // Update schema version
  this.setMetadata('schema_version', targetVersion);
  console.error(`[Database] Schema migrated to ${targetVersion}`);
}
```

4. Update upsertNode to accept templateId parameter:
```typescript
upsertNode(note: VaultNote, templateId: string = 'worldbuilding'): void {
  const stmt = this.db.prepare(`
    INSERT INTO nodes (id, type, status, title, content, frontmatter, file_path, template_id, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ON CONFLICT(id) DO UPDATE SET
      type = excluded.type,
      status = excluded.status,
      title = excluded.title,
      content = excluded.content,
      frontmatter = excluded.frontmatter,
      file_path = excluded.file_path,
      template_id = excluded.template_id,
      updated_at = excluded.updated_at
  `);

  stmt.run(
    note.id,
    note.frontmatter.type,
    note.frontmatter.status,
    note.frontmatter.title || note.fileName,
    note.content,
    JSON.stringify(note.frontmatter),
    note.filePath,
    templateId,
    note.stats.created.getTime(),
    note.stats.modified.getTime()
  );
}
```

5. Update getNode and getAllNodes to include template_id in returned GraphNode:
```typescript
// In getNode and getAllNodes, add to return:
templateId: row.template_id,
```

6. Update GraphNode interface in src/types/index.ts to include templateId:
```typescript
export interface GraphNode {
  id: string;
  type: NoteType;
  status: NoteStatus;
  title: string;
  content: string;
  properties: Record<string, any>;
  filePath: string;
  templateId?: string;  // Optional for backwards compat
  created: Date;
  updated: Date;
}
```
  </action>
  <verify>
Run `npm run build` - no TypeScript errors. Manually test that database initializes correctly.
  </verify>
  <done>
Nodes table has template_id column. Schema migration drops and recreates tables when version changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update GraphBuilder to Pass Template ID</name>
  <files>
    src/graph/builder.ts
    tests/graph/builder.test.ts
  </files>
  <action>
Modify GraphBuilder to accept and use templateId:

1. Add templateId property to GraphBuilder:
```typescript
export class GraphBuilder {
  private db: HivemindDatabase;
  private templateId: string;

  constructor(db: HivemindDatabase, templateId: string = 'worldbuilding') {
    this.db = db;
    this.templateId = templateId;
  }

  /**
   * Set the active template ID for subsequent builds
   */
  setTemplateId(templateId: string): void {
    this.templateId = templateId;
  }
  // ...
}
```

2. Update buildGraph to pass templateId to upsertNode:
```typescript
buildGraph(notes: VaultNote[]): void {
  // Clear existing nodes for this template (not all nodes)
  // For now, clear all - multi-template filtering comes later
  this.db.clear();

  for (const note of notes) {
    this.db.upsertNode(note, this.templateId);
    // ... relationship building
  }
}
```

3. Update server.ts to pass templateId to GraphBuilder:
```typescript
// In constructor or after template detection:
if (this.templateConfig) {
  this.graphBuilder.setTemplateId(this.templateConfig.activeTemplate);
}
```

4. Update existing tests in tests/graph/builder.test.ts to work with new constructor signature. The default 'worldbuilding' value means existing tests should still pass without changes, but add explicit test:
```typescript
it('should use default template ID when not specified', () => {
  const builder = new GraphBuilder(mockDb);
  // Should work with worldbuilding default
});

it('should use specified template ID', () => {
  const builder = new GraphBuilder(mockDb, 'research');
  // Should pass 'research' to upsertNode
});
```
  </action>
  <verify>
Run `npm test tests/graph/builder.test.ts` - all tests pass including new ones.
Run `npm test` - full test suite passes.
  </verify>
  <done>
GraphBuilder passes templateId to database when inserting nodes. Template ID flows from config through builder to database.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm test` passes all tests
3. Fresh database has nodes table with template_id column
4. Schema migration works: delete vault.db, restart, table has new schema
5. GraphBuilder.setTemplateId() method exists and works
</verification>

<success_criteria>
- [ ] nodes table has template_id column with DEFAULT 'worldbuilding'
- [ ] idx_nodes_template index created
- [ ] Schema version check triggers migration when needed
- [ ] Migration drops and recreates tables (not in-place ALTER)
- [ ] upsertNode accepts templateId parameter
- [ ] GraphNode interface includes optional templateId
- [ ] GraphBuilder constructor accepts optional templateId
- [ ] GraphBuilder.setTemplateId() method works
- [ ] All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-migration/07-02-SUMMARY.md`
</output>
