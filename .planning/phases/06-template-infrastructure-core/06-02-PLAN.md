---
phase: 06-template-infrastructure-core
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/templates/validator.ts
  - src/templates/registry.ts
  - src/templates/index.ts
autonomous: true

must_haves:
  truths:
    - "Invalid template configs are rejected with clear error messages"
    - "Template registry provides O(1) lookup by template ID"
    - "Registry validates templates on registration"
    - "Active template can be retrieved from registry"
  artifacts:
    - path: "src/templates/validator.ts"
      provides: "Template config validation with Zod"
      exports: ["validateTemplateConfig", "TemplateConfigSchema", "TemplateValidationError"]
    - path: "src/templates/registry.ts"
      provides: "Template registry singleton"
      exports: ["TemplateRegistry", "templateRegistry"]
  key_links:
    - from: "src/templates/validator.ts"
      to: "src/templates/types.ts"
      via: "validates against"
      pattern: "TemplateDefinition|EntityTypeConfig|FieldConfig"
    - from: "src/templates/registry.ts"
      to: "src/templates/validator.ts"
      via: "uses for validation"
      pattern: "validateTemplateConfig"
---

<objective>
Create template config validation and registry for managing template lifecycle.

Purpose: The validator ensures user config is valid before schema generation (fail-fast at startup). The registry provides centralized template management with O(1) lookups.

Output: Validator that catches config errors with helpful messages, registry that manages template registration and activation.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-infrastructure-core/06-RESEARCH.md

Reference:
@src/templates/types.ts (from Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create template config validator</name>
  <files>src/templates/validator.ts</files>
  <action>
Create `src/templates/validator.ts` using Zod for validation (already installed in project):

1. **FieldConfigSchema** - Validates individual field definitions:
   ```typescript
   const FieldTypeSchema = z.enum(['string', 'number', 'boolean', 'enum', 'array', 'date', 'record']);

   const FieldConfigSchema = z.object({
     name: z.string().min(1).regex(/^[a-z][a-zA-Z0-9_]*$/, 'Field name must be camelCase'),
     type: FieldTypeSchema,
     required: z.boolean().optional().default(false),
     default: z.unknown().optional(),
     enumValues: z.array(z.string()).optional(),
     arrayItemType: FieldTypeSchema.optional(),
     description: z.string().optional(),
   }).refine(
     (data) => data.type !== 'enum' || (data.enumValues && data.enumValues.length > 0),
     { message: 'enumValues required when type is enum', path: ['enumValues'] }
   ).refine(
     (data) => data.type !== 'array' || data.arrayItemType !== undefined,
     { message: 'arrayItemType recommended for array fields (defaults to string)', path: ['arrayItemType'] }
   );
   ```

2. **EntityTypeConfigSchema** - Validates entity type definitions:
   ```typescript
   const EntityTypeConfigSchema = z.object({
     name: z.string().min(1).regex(/^[a-z][a-z0-9_]*$/, 'Entity name must be lowercase with underscores'),
     displayName: z.string().min(1),
     pluralName: z.string().min(1),
     description: z.string().optional(),
     fields: z.array(FieldConfigSchema).min(1, 'Entity type must have at least one field'),
     icon: z.string().optional(),
   });
   ```

3. **TemplateDefinitionSchema** - Validates complete template:
   ```typescript
   const TemplateDefinitionSchema = z.object({
     id: z.string().min(1).regex(/^[a-z][a-z0-9-]*$/, 'Template ID must be lowercase with hyphens'),
     name: z.string().min(1),
     version: z.string().regex(/^\d+\.\d+\.\d+$/, 'Version must be semantic (e.g., 1.0.0)'),
     description: z.string().optional(),
     entityTypes: z.array(EntityTypeConfigSchema).min(1, 'Template must have at least one entity type'),
   }).refine(
     (data) => {
       const names = data.entityTypes.map(e => e.name);
       return new Set(names).size === names.length;
     },
     { message: 'Duplicate entity type names not allowed', path: ['entityTypes'] }
   );
   ```

4. **TemplateConfigSchema** - Validates full config file:
   ```typescript
   export const TemplateConfigSchema = z.object({
     templates: z.array(TemplateDefinitionSchema).optional().default([]),
     activeTemplate: z.string().min(1),
   });
   ```

5. **TemplateValidationError** - Custom error class:
   ```typescript
   export class TemplateValidationError extends Error {
     constructor(
       message: string,
       public readonly errors: z.ZodError['errors'],
       public readonly path?: string
     ) {
       super(message);
       this.name = 'TemplateValidationError';
     }

     toUserMessage(): string {
       const issues = this.errors.map(e => {
         const path = e.path.join('.');
         return `  - ${path}: ${e.message}`;
       }).join('\n');
       return `Template configuration is invalid:\n${issues}`;
     }
   }
   ```

6. **validateTemplateConfig** - Main validation function:
   ```typescript
   export function validateTemplateConfig(config: unknown): TemplateConfig {
     const result = TemplateConfigSchema.safeParse(config);
     if (!result.success) {
       throw new TemplateValidationError(
         'Invalid template configuration',
         result.error.errors
       );
     }
     return result.data;
   }
   ```

Export: `validateTemplateConfig`, `TemplateConfigSchema`, `TemplateValidationError`, and all individual schemas.

Use `.js` extension in imports for ESM compatibility.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.

Test validation catches errors:
```typescript
// In a test or scratch file:
import { validateTemplateConfig } from './src/templates/validator.js';
try {
  validateTemplateConfig({ activeTemplate: '' }); // Should throw
} catch (e) {
  console.log('Caught expected error:', e.message);
}
```
  </verify>
  <done>
Validator exports validateTemplateConfig that throws TemplateValidationError with user-friendly messages for invalid configs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create template registry</name>
  <files>src/templates/registry.ts</files>
  <action>
Create `src/templates/registry.ts` implementing the registry pattern:

1. **TemplateRegistry class**:
   ```typescript
   import type { TemplateDefinition, TemplateRegistryEntry, EntityTypeConfig } from './types.js';
   import { validateTemplateConfig, TemplateValidationError } from './validator.js';

   export class TemplateRegistry {
     private templates = new Map<string, TemplateRegistryEntry>();
     private activeTemplateId: string | null = null;

     /**
      * Register a template definition.
      * Validates the template and builds lookup maps.
      */
     register(template: TemplateDefinition, source: 'builtin' | 'config' = 'config'): void {
       // Validate template structure
       this.validateTemplate(template);

       // Build entity type lookup map
       const entityTypeMap = new Map<string, EntityTypeConfig>();
       for (const entityType of template.entityTypes) {
         entityTypeMap.set(entityType.name, entityType);
       }

       // Store with runtime metadata
       const entry: TemplateRegistryEntry = {
         ...template,
         source,
         entityTypeMap,
       };

       this.templates.set(template.id, entry);
     }

     /**
      * Activate a template by ID.
      * @throws Error if template not found
      */
     activate(templateId: string): void {
       if (!this.templates.has(templateId)) {
         const available = Array.from(this.templates.keys()).join(', ');
         throw new Error(
           `Template '${templateId}' not found. Available templates: ${available || 'none'}`
         );
       }
       this.activeTemplateId = templateId;
     }

     /**
      * Get the currently active template.
      * @returns Active template or null if none activated
      */
     getActive(): TemplateRegistryEntry | null {
       if (!this.activeTemplateId) return null;
       return this.templates.get(this.activeTemplateId) || null;
     }

     /**
      * Get a template by ID.
      */
     get(templateId: string): TemplateRegistryEntry | undefined {
       return this.templates.get(templateId);
     }

     /**
      * Check if a template is registered.
      */
     has(templateId: string): boolean {
       return this.templates.has(templateId);
     }

     /**
      * Get all registered template IDs.
      */
     listTemplates(): string[] {
       return Array.from(this.templates.keys());
     }

     /**
      * Get entity type config from active template.
      * @throws Error if no active template or entity type not found
      */
     getEntityType(entityTypeName: string): EntityTypeConfig {
       const active = this.getActive();
       if (!active) {
         throw new Error('No active template. Call activate() first.');
       }

       const entityType = active.entityTypeMap.get(entityTypeName);
       if (!entityType) {
         const available = Array.from(active.entityTypeMap.keys()).join(', ');
         throw new Error(
           `Entity type '${entityTypeName}' not found in template '${active.id}'. ` +
           `Available: ${available}`
         );
       }

       return entityType;
     }

     /**
      * Get all entity types from active template.
      */
     getEntityTypes(): EntityTypeConfig[] {
       const active = this.getActive();
       if (!active) return [];
       return Array.from(active.entityTypeMap.values());
     }

     /**
      * Clear all templates (useful for testing).
      */
     clear(): void {
       this.templates.clear();
       this.activeTemplateId = null;
     }

     private validateTemplate(template: TemplateDefinition): void {
       // Check required fields
       if (!template.id || !template.name || !template.version) {
         throw new Error('Template missing required fields: id, name, version');
       }

       // Check for entity types
       if (!template.entityTypes || template.entityTypes.length === 0) {
         throw new Error(`Template '${template.id}' has no entity types defined`);
       }

       // Check for duplicate entity names
       const names = new Set<string>();
       for (const entityType of template.entityTypes) {
         if (names.has(entityType.name)) {
           throw new Error(
             `Template '${template.id}' has duplicate entity type: ${entityType.name}`
           );
         }
         names.add(entityType.name);
       }
     }
   }
   ```

2. **Singleton instance**:
   ```typescript
   // Singleton for application-wide access
   export const templateRegistry = new TemplateRegistry();
   ```

Export both the class (for testing) and the singleton instance.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.

Test registry operations:
```typescript
import { TemplateRegistry } from './src/templates/registry.js';
const reg = new TemplateRegistry();
reg.register({
  id: 'test',
  name: 'Test',
  version: '1.0.0',
  entityTypes: [{ name: 'item', displayName: 'Item', pluralName: 'Items', fields: [{ name: 'title', type: 'string' }] }]
});
reg.activate('test');
console.log(reg.getActive()?.id); // 'test'
```
  </verify>
  <done>
Registry provides register(), activate(), getActive(), getEntityType() with O(1) lookups and clear error messages.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update module exports</name>
  <files>src/templates/index.ts</files>
  <action>
Update `src/templates/index.ts` to export validator and registry:

```typescript
/**
 * Template system for pluggable entity type definitions.
 *
 * This module enables users to define custom entity types via config
 * without writing code. The worldbuilding template becomes one of many
 * possible templates.
 *
 * @example
 * ```typescript
 * import { templateRegistry, validateTemplateConfig } from './templates';
 *
 * // Validate and register config
 * const config = validateTemplateConfig(userConfig);
 * for (const template of config.templates) {
 *   templateRegistry.register(template);
 * }
 * templateRegistry.activate(config.activeTemplate);
 *
 * // Use active template
 * const entityTypes = templateRegistry.getEntityTypes();
 * ```
 */

export * from './types.js';
export * from './validator.js';
export { TemplateRegistry, templateRegistry } from './registry.js';
```
  </action>
  <verify>
Run `npm run build` - compiles successfully.
Verify all exports available from barrel:
```bash
grep -E "^export" src/templates/index.ts
```
  </verify>
  <done>
Templates module exports types, validator, and registry from single entry point.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build passes:
   ```bash
   npm run build
   ```

2. Validator catches invalid configs:
   ```bash
   # Create test script
   node -e "
   import { validateTemplateConfig } from './dist/templates/index.js';
   try {
     validateTemplateConfig({ templates: [{ id: '123Invalid', name: 'X', version: 'bad', entityTypes: [] }], activeTemplate: 'test' });
   } catch (e) {
     console.log('Validation works:', e.message.includes('invalid'));
   }
   "
   ```

3. Registry operations work:
   ```bash
   node -e "
   import { TemplateRegistry } from './dist/templates/index.js';
   const r = new TemplateRegistry();
   r.register({ id: 'test', name: 'Test', version: '1.0.0', entityTypes: [{ name: 'item', displayName: 'Item', pluralName: 'Items', fields: [{ name: 'name', type: 'string' }] }] });
   r.activate('test');
   console.log('Registry works:', r.getActive()?.id === 'test');
   "
   ```
</verification>

<success_criteria>
- validateTemplateConfig throws TemplateValidationError for invalid configs
- TemplateValidationError.toUserMessage() provides human-readable errors
- TemplateRegistry provides O(1) template and entity type lookups
- Registry validates templates on registration
- All exports available from src/templates/index.ts
- npm run build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-infrastructure-core/06-02-SUMMARY.md`
</output>
