---
phase: 06-template-infrastructure-core
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - src/templates/loader.ts
  - src/templates/builtin/worldbuilding.ts
  - src/templates/index.ts
  - config.json
autonomous: true

must_haves:
  truths:
    - "System loads template definitions from config at startup"
    - "User can select active template via config.json"
    - "Worldbuilding template ships as built-in default"
    - "Config loading integrates with existing HivemindConfig"
  artifacts:
    - path: "src/templates/loader.ts"
      provides: "Config loading and template initialization"
      exports: ["loadTemplateConfig", "initializeTemplates"]
    - path: "src/templates/builtin/worldbuilding.ts"
      provides: "Built-in worldbuilding template definition"
      exports: ["worldbuildingTemplate"]
  key_links:
    - from: "src/templates/loader.ts"
      to: "src/templates/registry.ts"
      via: "registers templates"
      pattern: "templateRegistry\\.register"
    - from: "src/templates/loader.ts"
      to: "src/templates/validator.ts"
      via: "validates config"
      pattern: "validateTemplateConfig"
    - from: "src/templates/loader.ts"
      to: "config.json"
      via: "reads template config"
      pattern: "template|activeTemplate"
---

<objective>
Create config loading system and built-in worldbuilding template.

Purpose: This plan wires everything together - loading config at startup, registering templates, and activating the user's selected template. Also creates the worldbuilding template as the default.

Output: Complete template initialization flow that runs at server startup.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-infrastructure-core/06-RESEARCH.md

Reference:
@src/templates/types.ts (from Plan 01)
@src/templates/validator.ts (from Plan 02)
@src/templates/registry.ts (from Plan 02)
@src/templates/schema-factory.ts (from Plan 03)
@src/types/index.ts (HivemindConfig interface, existing entity schemas)
@config.json (current config structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create built-in worldbuilding template</name>
  <files>src/templates/builtin/worldbuilding.ts</files>
  <action>
Create `src/templates/builtin/worldbuilding.ts` defining the worldbuilding template that matches existing hardcoded schemas:

```typescript
import type { TemplateDefinition } from '../types.js';

/**
 * Built-in worldbuilding template.
 *
 * This template defines entity types for fictional worldbuilding:
 * characters, locations, events, factions, lore, and assets.
 *
 * It matches the existing hardcoded schemas in src/types/index.ts
 * to ensure backwards compatibility during migration.
 */
export const worldbuildingTemplate: TemplateDefinition = {
  id: 'worldbuilding',
  name: 'Worldbuilding',
  version: '1.0.0',
  description: 'Entity types for fictional worldbuilding: characters, locations, events, factions, lore, and assets.',

  entityTypes: [
    // Character entity type
    {
      name: 'character',
      displayName: 'Character',
      pluralName: 'Characters',
      description: 'A person, creature, or sentient being in your world.',
      icon: 'user',
      fields: [
        { name: 'age', type: 'number', description: 'Character age' },
        { name: 'gender', type: 'string', description: 'Character gender' },
        { name: 'race', type: 'string', description: 'Species or race' },
        {
          name: 'appearance',
          type: 'record',
          description: 'Physical appearance details (hair, eyes, build, etc.)',
        },
        {
          name: 'personality',
          type: 'record',
          description: 'Personality traits and characteristics',
        },
        {
          name: 'relationships',
          type: 'array',
          arrayItemType: 'string',
          description: 'Related entity IDs',
        },
        {
          name: 'assets',
          type: 'array',
          arrayItemType: 'string',
          description: 'Associated asset IDs (portraits, etc.)',
        },
      ],
    },

    // Location entity type
    {
      name: 'location',
      displayName: 'Location',
      pluralName: 'Locations',
      description: 'A place in your world: region, city, building, or room.',
      icon: 'map-pin',
      fields: [
        { name: 'region', type: 'string', description: 'Parent region' },
        { name: 'category', type: 'string', description: 'Location category' },
        { name: 'parent', type: 'string', description: 'Parent location ID' },
        {
          name: 'hierarchy_level',
          type: 'enum',
          enumValues: ['continent', 'region', 'settlement', 'building', 'room'],
          description: 'Level in location hierarchy',
        },
        {
          name: 'children',
          type: 'array',
          arrayItemType: 'string',
          description: 'Child location IDs',
        },
        { name: 'climate', type: 'string', description: 'Climate description' },
        {
          name: 'terrain',
          type: 'array',
          arrayItemType: 'string',
          description: 'Terrain types',
        },
        {
          name: 'inhabitants',
          type: 'array',
          arrayItemType: 'string',
          description: 'Inhabitant entity IDs',
        },
        {
          name: 'connections',
          type: 'array',
          arrayItemType: 'string',
          description: 'Connected location IDs',
        },
        {
          name: 'assets',
          type: 'array',
          arrayItemType: 'string',
          description: 'Associated asset IDs (maps, etc.)',
        },
      ],
    },

    // Event entity type
    {
      name: 'event',
      displayName: 'Event',
      pluralName: 'Events',
      description: 'A historical or current event in your world.',
      icon: 'calendar',
      fields: [
        { name: 'date', type: 'string', description: 'Event date (flexible format)' },
        { name: 'date_start', type: 'string', description: 'Start date for ranges' },
        { name: 'date_end', type: 'string', description: 'End date for ranges' },
        { name: 'date_display', type: 'string', description: 'Human-readable date' },
        { name: 'event_type', type: 'string', description: 'Type of event' },
        {
          name: 'participants',
          type: 'array',
          arrayItemType: 'string',
          description: 'Participant entity IDs',
        },
        {
          name: 'locations',
          type: 'array',
          arrayItemType: 'string',
          description: 'Location IDs where event occurred',
        },
        {
          name: 'factions',
          type: 'array',
          arrayItemType: 'string',
          description: 'Faction IDs involved',
        },
        { name: 'outcome', type: 'string', description: 'Event outcome' },
        {
          name: 'consequences',
          type: 'array',
          arrayItemType: 'string',
          description: 'Resulting effects',
        },
        { name: 'timeline', type: 'string', description: 'Timeline ID' },
        { name: 'previous_event', type: 'string', description: 'Previous event ID' },
        { name: 'next_event', type: 'string', description: 'Next event ID' },
      ],
    },

    // Faction entity type
    {
      name: 'faction',
      displayName: 'Faction',
      pluralName: 'Factions',
      description: 'An organization, group, or political entity.',
      icon: 'users',
      fields: [
        {
          name: 'faction_type',
          type: 'enum',
          enumValues: ['house', 'guild', 'organization', 'government', 'military', 'religion', 'other'],
          description: 'Type of faction',
        },
        { name: 'leader', type: 'string', description: 'Leader entity ID' },
        {
          name: 'members',
          type: 'array',
          arrayItemType: 'string',
          description: 'Member entity IDs',
        },
        { name: 'headquarters', type: 'string', description: 'HQ location ID' },
        { name: 'founded', type: 'string', description: 'Founding date' },
        {
          name: 'goals',
          type: 'array',
          arrayItemType: 'string',
          description: 'Faction goals',
        },
        {
          name: 'resources',
          type: 'array',
          arrayItemType: 'string',
          description: 'Faction resources',
        },
        {
          name: 'allies',
          type: 'array',
          arrayItemType: 'string',
          description: 'Allied faction IDs',
        },
        {
          name: 'rivals',
          type: 'array',
          arrayItemType: 'string',
          description: 'Rival faction IDs',
        },
      ],
    },

    // Lore entity type
    {
      name: 'lore',
      displayName: 'Lore',
      pluralName: 'Lore',
      description: 'World facts, mythology, history, or background information.',
      icon: 'book-open',
      fields: [
        {
          name: 'category',
          type: 'enum',
          enumValues: ['mythology', 'history', 'magic', 'technology', 'culture', 'religion', 'other'],
          description: 'Lore category',
        },
        {
          name: 'related_entities',
          type: 'array',
          arrayItemType: 'string',
          description: 'Related entity IDs',
        },
        {
          name: 'source',
          type: 'enum',
          enumValues: ['in-world', 'meta', 'player-knowledge'],
          description: 'Source of knowledge',
        },
      ],
    },

    // Asset entity type
    {
      name: 'asset',
      displayName: 'Asset',
      pluralName: 'Assets',
      description: 'AI-generated images, audio, or other media.',
      icon: 'image',
      fields: [
        {
          name: 'asset_type',
          type: 'enum',
          enumValues: ['image', 'audio', 'video', 'document'],
          default: 'image',
          description: 'Type of asset',
        },
        { name: 'file_path', type: 'string', required: true, description: 'Path to asset file' },
        { name: 'file_format', type: 'string', description: 'File format (png, jpg, etc.)' },
        {
          name: 'depicts',
          type: 'array',
          arrayItemType: 'string',
          description: 'Entity IDs depicted',
        },
        { name: 'generation_date', type: 'string', description: 'When asset was generated' },
        { name: 'generator', type: 'string', description: 'Tool used to generate' },
        { name: 'workflow_id', type: 'string', description: 'ComfyUI workflow ID' },
        { name: 'prompt', type: 'string', description: 'Generation prompt' },
        { name: 'negative_prompt', type: 'string', description: 'Negative prompt' },
        { name: 'model', type: 'string', description: 'Model used' },
        { name: 'seed', type: 'number', description: 'Random seed' },
        { name: 'parameters', type: 'record', description: 'Additional generation parameters' },
        { name: 'approved_by', type: 'string', description: 'Who approved this asset' },
        { name: 'approval_date', type: 'string', description: 'When asset was approved' },
      ],
    },
  ],
};
```

This template matches the existing schemas in `src/types/index.ts` to ensure backwards compatibility.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify file exists: `ls src/templates/builtin/worldbuilding.ts`
  </verify>
  <done>
Worldbuilding template defined with all 6 entity types matching existing schemas.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create config loader</name>
  <files>src/templates/loader.ts</files>
  <action>
Create `src/templates/loader.ts` for loading and initializing templates:

```typescript
import { readFileSync, existsSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import type { TemplateConfig, TemplateDefinition } from './types.js';
import { validateTemplateConfig, TemplateValidationError } from './validator.js';
import { templateRegistry } from './registry.js';
import { schemaFactory } from './schema-factory.js';
import { worldbuildingTemplate } from './builtin/worldbuilding.js';

/**
 * Default template config when none specified.
 */
const DEFAULT_CONFIG: TemplateConfig = {
  templates: [],
  activeTemplate: 'worldbuilding',
};

/**
 * Load template configuration from config.json or use defaults.
 *
 * Looks for `template` section in existing config.json structure.
 * Falls back to worldbuilding template if no config specified.
 *
 * @param configPath - Path to config.json (optional, auto-detected if not provided)
 * @returns Validated template configuration
 * @throws TemplateValidationError if config is invalid
 */
export function loadTemplateConfig(configPath?: string): TemplateConfig {
  // Find config file
  const resolvedPath = configPath || findConfigFile();

  if (!resolvedPath || !existsSync(resolvedPath)) {
    console.log('[templates] No config.json found, using default worldbuilding template');
    return DEFAULT_CONFIG;
  }

  try {
    const configData = JSON.parse(readFileSync(resolvedPath, 'utf-8'));

    // Check for template section in config
    if (!configData.template) {
      console.log('[templates] No template section in config.json, using default worldbuilding template');
      return DEFAULT_CONFIG;
    }

    // Validate template config
    const templateConfig = validateTemplateConfig(configData.template);
    console.log(`[templates] Loaded template config: activeTemplate=${templateConfig.activeTemplate}`);

    return templateConfig;
  } catch (error) {
    if (error instanceof TemplateValidationError) {
      console.error('[templates] Invalid template configuration:');
      console.error(error.toUserMessage());
      throw error;
    }
    if (error instanceof SyntaxError) {
      throw new Error(`[templates] Invalid JSON in config file: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Find config.json file by searching common locations.
 */
function findConfigFile(): string | null {
  // Try current working directory first
  const cwdConfig = join(process.cwd(), 'config.json');
  if (existsSync(cwdConfig)) {
    return cwdConfig;
  }

  // Try relative to this module (for development)
  const __dirname = dirname(fileURLToPath(import.meta.url));
  const moduleConfig = join(__dirname, '..', '..', 'config.json');
  if (existsSync(moduleConfig)) {
    return moduleConfig;
  }

  return null;
}

/**
 * Initialize the template system.
 *
 * This function:
 * 1. Registers all built-in templates
 * 2. Loads and validates user config
 * 3. Registers user-defined templates
 * 4. Activates the selected template
 * 5. Pre-generates schemas for the active template
 *
 * Call this once at server startup.
 *
 * @param configPath - Optional path to config.json
 * @returns The active template definition
 * @throws Error if template initialization fails
 */
export function initializeTemplates(configPath?: string): TemplateDefinition {
  // Clear any previous state (for testing)
  templateRegistry.clear();
  schemaFactory.clearCache();

  // 1. Register built-in templates
  console.log('[templates] Registering built-in templates...');
  templateRegistry.register(worldbuildingTemplate, 'builtin');
  console.log(`[templates] Registered: ${worldbuildingTemplate.id} (${worldbuildingTemplate.entityTypes.length} entity types)`);

  // 2. Load user config
  const config = loadTemplateConfig(configPath);

  // 3. Register user-defined templates
  if (config.templates && config.templates.length > 0) {
    console.log(`[templates] Registering ${config.templates.length} user template(s)...`);
    for (const template of config.templates) {
      templateRegistry.register(template, 'config');
      console.log(`[templates] Registered: ${template.id} (${template.entityTypes.length} entity types)`);
    }
  }

  // 4. Activate selected template
  console.log(`[templates] Activating template: ${config.activeTemplate}`);
  templateRegistry.activate(config.activeTemplate);

  // 5. Pre-generate schemas for active template
  const active = templateRegistry.getActive()!;
  console.log(`[templates] Generating schemas for ${active.entityTypes.length} entity types...`);
  schemaFactory.generateSchemas(active.id, active.entityTypes);

  console.log(`[templates] Template system initialized. Active: ${active.name} v${active.version}`);
  return active;
}

/**
 * Get a Zod schema for an entity type in the active template.
 *
 * Convenience function that combines registry lookup with schema factory.
 *
 * @param entityTypeName - Name of the entity type (e.g., 'character')
 * @returns Zod schema for the entity type
 * @throws Error if no active template or entity type not found
 */
export function getEntitySchema(entityTypeName: string) {
  const active = templateRegistry.getActive();
  if (!active) {
    throw new Error('No active template. Call initializeTemplates() first.');
  }

  const entityConfig = templateRegistry.getEntityType(entityTypeName);
  return schemaFactory.getSchema(active.id, entityConfig);
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.
Verify file exists: `ls src/templates/loader.ts`
  </verify>
  <done>
Config loader can load template config from config.json, register built-ins, and initialize the system.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update module exports and config structure</name>
  <files>src/templates/index.ts, config.json</files>
  <action>
1. Update `src/templates/index.ts` to export loader:

```typescript
/**
 * Template system for pluggable entity type definitions.
 *
 * This module enables users to define custom entity types via config
 * without writing code. The worldbuilding template becomes one of many
 * possible templates.
 *
 * ## Quick Start
 *
 * ```typescript
 * import { initializeTemplates, getEntitySchema } from './templates';
 *
 * // Initialize at startup (loads config.json automatically)
 * initializeTemplates();
 *
 * // Get schemas for entity validation
 * const characterSchema = getEntitySchema('character');
 * const parsed = characterSchema.parse(rawFrontmatter);
 * ```
 *
 * ## Config Structure
 *
 * Add a `template` section to your config.json:
 *
 * ```json
 * {
 *   "template": {
 *     "activeTemplate": "worldbuilding",
 *     "templates": []
 *   }
 * }
 * ```
 */

export * from './types.js';
export * from './validator.js';
export { TemplateRegistry, templateRegistry } from './registry.js';
export { createEntitySchema, SchemaFactory, schemaFactory } from './schema-factory.js';
export type { InferEntityType } from './schema-factory.js';
export { loadTemplateConfig, initializeTemplates, getEntitySchema } from './loader.js';
export { worldbuildingTemplate } from './builtin/worldbuilding.js';
```

2. Update `config.json` to add template section:

Read the current config.json, then add the template section. The structure should be:

```json
{
  "vault": { ... },
  "server": { ... },
  "indexing": { ... },
  "comfyui": { ... },
  "template": {
    "activeTemplate": "worldbuilding",
    "templates": []
  }
}
```

Keep all existing config values, just add the `template` key.
  </action>
  <verify>
Run `npm run build` - compiles successfully.

Test initialization:
```bash
node -e "
import { initializeTemplates, getEntitySchema } from './dist/templates/index.js';
const active = initializeTemplates();
console.log('Active template:', active.id);
const schema = getEntitySchema('character');
console.log('Character schema works:', !!schema);
"
```
  </verify>
  <done>
Complete template system exports. Config.json updated with template section defaulting to worldbuilding.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build passes:
   ```bash
   npm run build
   ```

2. Template initialization works:
   ```bash
   node -e "
   import { initializeTemplates, templateRegistry, getEntitySchema } from './dist/templates/index.js';

   // Initialize
   initializeTemplates();

   // Check registry
   console.log('Registered templates:', templateRegistry.listTemplates());
   console.log('Active template:', templateRegistry.getActive()?.id);

   // Check entity types
   const types = templateRegistry.getEntityTypes();
   console.log('Entity types:', types.map(t => t.name));

   // Check schema generation
   const charSchema = getEntitySchema('character');
   const result = charSchema.safeParse({
     id: 'gandalf',
     type: 'character',
     name: 'Gandalf',
     race: 'Maiar',
     age: 2019
   });
   console.log('Schema validation works:', result.success);
   "
   ```

3. Config.json has template section:
   ```bash
   node -e "const c = require('./config.json'); console.log('Template section:', c.template);"
   ```
</verification>

<success_criteria>
- initializeTemplates() loads built-in worldbuilding template
- Template can be selected via config.json `template.activeTemplate`
- User-defined templates in `template.templates` array are registered
- getEntitySchema() returns working Zod schemas
- All 6 worldbuilding entity types available: character, location, event, faction, lore, asset
- Config.json updated with template section
- npm run build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-infrastructure-core/06-04-SUMMARY.md`
</output>
