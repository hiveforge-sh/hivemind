---
phase: 06-template-infrastructure-core
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/templates/schema-factory.ts
  - src/templates/index.ts
autonomous: true

must_haves:
  truths:
    - "System generates Zod schemas dynamically from template config"
    - "Generated schemas support all field types (string, number, boolean, enum, array, date, record)"
    - "Generated schemas include base fields (id, type, status, etc.)"
    - "Schemas are cached for performance (generated once per entity type)"
  artifacts:
    - path: "src/templates/schema-factory.ts"
      provides: "Zod schema generation from EntityTypeConfig"
      exports: ["createEntitySchema", "SchemaFactory", "schemaFactory"]
  key_links:
    - from: "src/templates/schema-factory.ts"
      to: "src/templates/types.ts"
      via: "reads config from"
      pattern: "EntityTypeConfig|FieldConfig"
    - from: "src/templates/schema-factory.ts"
      to: "src/types/index.ts"
      via: "extends base schemas"
      pattern: "BaseFrontmatterSchema|NoteStatusSchema"
---

<objective>
Create schema factory that generates Zod schemas from template entity type configurations.

Purpose: This is the core of the template system - transforming user-defined config into runtime-validated schemas. Enables custom entity types without code changes.

Output: Factory functions that take EntityTypeConfig and produce Zod schemas matching the existing schema structure.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-template-infrastructure-core/06-RESEARCH.md

Reference:
@src/templates/types.ts (from Plan 01)
@src/types/index.ts (existing schemas to match structure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema factory</name>
  <files>src/templates/schema-factory.ts</files>
  <action>
Create `src/templates/schema-factory.ts` implementing Zod schema generation:

1. **Field schema builder** - Maps FieldConfig to Zod schema:
   ```typescript
   import { z, ZodTypeAny } from 'zod';
   import type { FieldConfig, EntityTypeConfig, FieldType } from './types.js';
   import { BaseFrontmatterSchema, NoteStatusSchema } from '../types/index.js';

   /**
    * Build a Zod schema for a single field based on its config.
    */
   function buildFieldSchema(field: FieldConfig): ZodTypeAny {
     let schema: ZodTypeAny;

     switch (field.type) {
       case 'string':
         schema = z.string();
         break;

       case 'number':
         schema = z.number();
         break;

       case 'boolean':
         schema = z.boolean();
         break;

       case 'date':
         // Accept ISO date strings
         schema = z.string().datetime({ offset: true }).or(z.string().date());
         break;

       case 'enum':
         if (!field.enumValues || field.enumValues.length === 0) {
           throw new Error(`Field '${field.name}' is enum but has no enumValues`);
         }
         schema = z.enum(field.enumValues as [string, ...string[]]);
         break;

       case 'array':
         const itemType = field.arrayItemType || 'string';
         const itemSchema = buildPrimitiveSchema(itemType);
         schema = z.array(itemSchema);
         break;

       case 'record':
         // Flexible key-value object
         schema = z.record(z.string(), z.any());
         break;

       default:
         // Fallback for unknown types
         schema = z.unknown();
     }

     // Apply optionality
     if (!field.required) {
       schema = schema.optional();
     }

     // Apply default value
     if (field.default !== undefined) {
       schema = schema.default(field.default);
     }

     return schema;
   }

   /**
    * Build primitive schema for array items.
    */
   function buildPrimitiveSchema(type: FieldType): ZodTypeAny {
     switch (type) {
       case 'string': return z.string();
       case 'number': return z.number();
       case 'boolean': return z.boolean();
       case 'date': return z.string();
       default: return z.string();
     }
   }
   ```

2. **Entity schema builder** - Creates complete entity schema:
   ```typescript
   /**
    * Create a Zod schema for an entity type based on its config.
    *
    * The generated schema extends BaseFrontmatterSchema and adds:
    * - A literal type field matching the entity name
    * - A name field (required for all entities)
    * - All custom fields from the config
    *
    * @example
    * ```typescript
    * const characterConfig: EntityTypeConfig = {
    *   name: 'character',
    *   displayName: 'Character',
    *   pluralName: 'Characters',
    *   fields: [
    *     { name: 'age', type: 'number' },
    *     { name: 'race', type: 'string' }
    *   ]
    * };
    * const CharacterSchema = createEntitySchema(characterConfig);
    * ```
    */
   export function createEntitySchema(config: EntityTypeConfig): z.ZodObject<any> {
     // Build custom fields object
     const customFields: Record<string, ZodTypeAny> = {};

     for (const field of config.fields) {
       customFields[field.name] = buildFieldSchema(field);
     }

     // Extend base schema with entity-specific type and custom fields
     return BaseFrontmatterSchema.extend({
       type: z.literal(config.name),
       name: z.string(), // All entities have a name
       ...customFields,
     });
   }
   ```

3. **SchemaFactory class** - Manages schema generation with caching:
   ```typescript
   /**
    * Factory for generating and caching Zod schemas from entity type configs.
    *
    * Schemas are generated once per entity type and cached for performance.
    * The cache is keyed by template ID + entity name to handle template switching.
    */
   export class SchemaFactory {
     private schemaCache = new Map<string, z.ZodObject<any>>();

     /**
      * Get or create a schema for an entity type.
      *
      * @param templateId - ID of the template (for cache key)
      * @param entityConfig - Entity type configuration
      * @returns Zod schema for the entity type
      */
     getSchema(templateId: string, entityConfig: EntityTypeConfig): z.ZodObject<any> {
       const cacheKey = `${templateId}:${entityConfig.name}`;

       let schema = this.schemaCache.get(cacheKey);
       if (!schema) {
         schema = createEntitySchema(entityConfig);
         this.schemaCache.set(cacheKey, schema);
       }

       return schema;
     }

     /**
      * Generate schemas for all entity types in a template.
      *
      * @param templateId - ID of the template
      * @param entityConfigs - Array of entity type configurations
      * @returns Map of entity name to Zod schema
      */
     generateSchemas(
       templateId: string,
       entityConfigs: EntityTypeConfig[]
     ): Map<string, z.ZodObject<any>> {
       const schemas = new Map<string, z.ZodObject<any>>();

       for (const config of entityConfigs) {
         const schema = this.getSchema(templateId, config);
         schemas.set(config.name, schema);
       }

       return schemas;
     }

     /**
      * Clear the schema cache (useful for testing or hot reload).
      */
     clearCache(): void {
       this.schemaCache.clear();
     }

     /**
      * Get cache statistics for debugging.
      */
     getCacheStats(): { size: number; keys: string[] } {
       return {
         size: this.schemaCache.size,
         keys: Array.from(this.schemaCache.keys()),
       };
     }
   }

   // Singleton instance
   export const schemaFactory = new SchemaFactory();
   ```

4. **Type inference helper**:
   ```typescript
   /**
    * Infer TypeScript type from a dynamically generated schema.
    *
    * Note: This returns `any` at compile time since schemas are dynamic.
    * Runtime validation still works correctly.
    */
   export type InferEntityType<T extends z.ZodObject<any>> = z.infer<T>;
   ```

Export: `createEntitySchema`, `SchemaFactory`, `schemaFactory`, `InferEntityType`.
  </action>
  <verify>
Run `npx tsc --noEmit` - no type errors.

Test schema generation:
```typescript
import { createEntitySchema } from './src/templates/schema-factory.js';
const schema = createEntitySchema({
  name: 'test',
  displayName: 'Test',
  pluralName: 'Tests',
  fields: [
    { name: 'title', type: 'string', required: true },
    { name: 'count', type: 'number' }
  ]
});
console.log(schema.parse({ id: 'x', type: 'test', name: 'Test', title: 'Hello' }));
```
  </verify>
  <done>
Schema factory generates Zod schemas from EntityTypeConfig. Schemas extend BaseFrontmatterSchema and include all custom fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add schema factory to exports</name>
  <files>src/templates/index.ts</files>
  <action>
Update `src/templates/index.ts` to include schema factory exports:

```typescript
/**
 * Template system for pluggable entity type definitions.
 *
 * This module enables users to define custom entity types via config
 * without writing code. The worldbuilding template becomes one of many
 * possible templates.
 *
 * @example
 * ```typescript
 * import { templateRegistry, validateTemplateConfig, schemaFactory } from './templates';
 *
 * // Validate and register config
 * const config = validateTemplateConfig(userConfig);
 * for (const template of config.templates) {
 *   templateRegistry.register(template);
 * }
 * templateRegistry.activate(config.activeTemplate);
 *
 * // Generate schemas for active template
 * const active = templateRegistry.getActive()!;
 * const schemas = schemaFactory.generateSchemas(active.id, active.entityTypes);
 *
 * // Validate entity data
 * const characterSchema = schemas.get('character');
 * const parsed = characterSchema.parse(rawData);
 * ```
 */

export * from './types.js';
export * from './validator.js';
export { TemplateRegistry, templateRegistry } from './registry.js';
export { createEntitySchema, SchemaFactory, schemaFactory } from './schema-factory.js';
export type { InferEntityType } from './schema-factory.js';
```
  </action>
  <verify>
Run `npm run build` - compiles successfully.
Check exports:
```bash
grep "export" src/templates/index.ts
```
  </verify>
  <done>
Schema factory exports added to templates module.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write schema factory tests</name>
  <files>src/templates/__tests__/schema-factory.test.ts</files>
  <action>
Create `src/templates/__tests__/schema-factory.test.ts` with comprehensive tests:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { createEntitySchema, SchemaFactory } from '../schema-factory.js';
import type { EntityTypeConfig, FieldConfig } from '../types.js';

describe('createEntitySchema', () => {
  it('creates schema with string fields', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'title', type: 'string', required: true }],
    };

    const schema = createEntitySchema(config);
    const result = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test Entity',
      title: 'Hello',
    });

    expect(result.success).toBe(true);
  });

  it('creates schema with number fields', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'age', type: 'number' }],
    };

    const schema = createEntitySchema(config);
    const result = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      age: 25,
    });

    expect(result.success).toBe(true);
  });

  it('creates schema with enum fields', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{
        name: 'status',
        type: 'enum',
        enumValues: ['active', 'inactive'],
      }],
    };

    const schema = createEntitySchema(config);

    // Valid enum value
    const validResult = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      status: 'active',
    });
    expect(validResult.success).toBe(true);

    // Invalid enum value
    const invalidResult = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      status: 'unknown',
    });
    expect(invalidResult.success).toBe(false);
  });

  it('creates schema with array fields', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{
        name: 'tags',
        type: 'array',
        arrayItemType: 'string',
      }],
    };

    const schema = createEntitySchema(config);
    const result = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      tags: ['a', 'b', 'c'],
    });

    expect(result.success).toBe(true);
  });

  it('makes fields optional by default', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'optional', type: 'string' }],
    };

    const schema = createEntitySchema(config);
    const result = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      // optional field not provided
    });

    expect(result.success).toBe(true);
  });

  it('enforces required fields', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'required', type: 'string', required: true }],
    };

    const schema = createEntitySchema(config);
    const result = schema.safeParse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
      // required field missing
    });

    expect(result.success).toBe(false);
  });

  it('applies default values', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{
        name: 'count',
        type: 'number',
        default: 0,
      }],
    };

    const schema = createEntitySchema(config);
    const result = schema.parse({
      id: 'test-1',
      type: 'test',
      name: 'Test',
    });

    expect(result.count).toBe(0);
  });

  it('enforces type literal for entity type', () => {
    const config: EntityTypeConfig = {
      name: 'character',
      displayName: 'Character',
      pluralName: 'Characters',
      fields: [],
    };

    const schema = createEntitySchema(config);

    // Correct type
    const validResult = schema.safeParse({
      id: 'char-1',
      type: 'character',
      name: 'Test',
    });
    expect(validResult.success).toBe(true);

    // Wrong type
    const invalidResult = schema.safeParse({
      id: 'char-1',
      type: 'location',
      name: 'Test',
    });
    expect(invalidResult.success).toBe(false);
  });
});

describe('SchemaFactory', () => {
  let factory: SchemaFactory;

  beforeEach(() => {
    factory = new SchemaFactory();
  });

  it('caches schemas by template and entity name', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'value', type: 'string' }],
    };

    const schema1 = factory.getSchema('template-1', config);
    const schema2 = factory.getSchema('template-1', config);

    // Same instance (cached)
    expect(schema1).toBe(schema2);
  });

  it('generates different schemas for different templates', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [{ name: 'value', type: 'string' }],
    };

    const schema1 = factory.getSchema('template-1', config);
    const schema2 = factory.getSchema('template-2', config);

    // Different instances (different templates)
    expect(schema1).not.toBe(schema2);
  });

  it('generates schemas for all entity types', () => {
    const configs: EntityTypeConfig[] = [
      { name: 'character', displayName: 'Character', pluralName: 'Characters', fields: [] },
      { name: 'location', displayName: 'Location', pluralName: 'Locations', fields: [] },
    ];

    const schemas = factory.generateSchemas('test', configs);

    expect(schemas.size).toBe(2);
    expect(schemas.has('character')).toBe(true);
    expect(schemas.has('location')).toBe(true);
  });

  it('clears cache', () => {
    const config: EntityTypeConfig = {
      name: 'test',
      displayName: 'Test',
      pluralName: 'Tests',
      fields: [],
    };

    factory.getSchema('template-1', config);
    expect(factory.getCacheStats().size).toBe(1);

    factory.clearCache();
    expect(factory.getCacheStats().size).toBe(0);
  });
});
```
  </action>
  <verify>
Run tests:
```bash
npm test -- src/templates/__tests__/schema-factory.test.ts
```
All tests should pass.
  </verify>
  <done>
Schema factory has comprehensive test coverage for all field types, caching, and edge cases.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Build passes:
   ```bash
   npm run build
   ```

2. Tests pass:
   ```bash
   npm test -- src/templates
   ```

3. Schema generation works end-to-end:
   ```bash
   node -e "
   import { createEntitySchema } from './dist/templates/index.js';
   const schema = createEntitySchema({
     name: 'character',
     displayName: 'Character',
     pluralName: 'Characters',
     fields: [
       { name: 'age', type: 'number' },
       { name: 'race', type: 'string' },
       { name: 'status', type: 'enum', enumValues: ['alive', 'dead'] }
     ]
   });
   const result = schema.parse({
     id: 'char-1',
     type: 'character',
     name: 'Gandalf',
     age: 2019,
     race: 'Maiar',
     status: 'alive'
   });
   console.log('Schema generation works:', result.name === 'Gandalf');
   "
   ```
</verification>

<success_criteria>
- createEntitySchema generates valid Zod schemas from EntityTypeConfig
- All field types supported: string, number, boolean, enum, array, date, record
- Generated schemas extend BaseFrontmatterSchema
- SchemaFactory caches schemas for performance
- All tests pass
- npm run build completes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-template-infrastructure-core/06-03-SUMMARY.md`
</output>
