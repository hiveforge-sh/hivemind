---
phase: 15-fix-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/fix/types.ts
  - src/cli/fix/id-generator.ts
  - src/cli/fix/fixer.ts
autonomous: true

must_haves:
  truths:
    - "Fixer analyzes validation results and generates missing frontmatter"
    - "ID generator creates slugified IDs from filenames with collision detection"
    - "Partial frontmatter files only get missing required fields added"
  artifacts:
    - path: "src/cli/fix/types.ts"
      provides: "FixOptions, FixResult, FileOperation types"
      exports: ["FixOptions", "FixResult", "FileOperation"]
    - path: "src/cli/fix/id-generator.ts"
      provides: "ID generation with collision detection"
      exports: ["generateUniqueId", "collectExistingIds"]
    - path: "src/cli/fix/fixer.ts"
      provides: "Core fix logic for generating frontmatter"
      exports: ["FileFixer"]
  key_links:
    - from: "src/cli/fix/fixer.ts"
      to: "src/cli/validate/scanner.ts"
      via: "imports ValidationScanner"
      pattern: "import.*ValidationScanner"
    - from: "src/cli/fix/fixer.ts"
      to: "src/templates/registry.ts"
      via: "gets active template for schema"
      pattern: "templateRegistry\\.getActive"
---

<objective>
Create fix command core infrastructure: types, ID generator, and fixer logic

Purpose: Enable safe bulk addition of frontmatter to markdown files by analyzing validation results and generating correct frontmatter based on template schemas

Output: Types module, ID generator with collision detection, and FileFixer class that analyzes files and generates frontmatter operations
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/15-fix-cli/15-CONTEXT.md
@.planning/phases/15-fix-cli/15-RESEARCH.md

# Reuse validation infrastructure patterns
@src/cli/validate/types.ts
@src/cli/validate/scanner.ts
@src/cli/validate/validator.ts

# Template registry for entity types
@src/templates/registry.ts
@src/templates/folder-mapper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fix types module</name>
  <files>src/cli/fix/types.ts</files>
  <action>
Create types module with discriminated unions for fix operations:

```typescript
/**
 * Options for the fix command.
 */
export interface FixOptions {
  vaultPath: string;
  apply: boolean;           // --apply flag (default false = dry-run)
  yes: boolean;             // --yes flag (skip prompts)
  json: boolean;            // --json flag (machine output)
  verbose: boolean;         // --verbose flag (show file list)
  type?: string;            // --type flag (override folder mapping)
  ignorePatterns?: string[];// --ignore flag
}

/**
 * Operation to perform on a single file.
 */
export interface FileOperation {
  path: string;             // Relative path from vault
  entityType: string;       // Resolved or selected entity type
  fieldsToAdd: string[];    // Field names being added
  hasExistingFrontmatter: boolean;
  frontmatter: Record<string, unknown>; // Generated frontmatter
}

/**
 * Result of fix operation.
 */
export interface FixResult {
  success: boolean;
  operations: FileOperation[];
  applied: boolean;         // Whether changes were written
  summary: FixSummary;
}

/**
 * Summary statistics for fix operation.
 */
export interface FixSummary {
  totalFiles: number;
  fixedFiles: number;
  skippedFiles: number;     // Ambiguous types in --yes mode
  failedFiles: number;      // Files that couldn't be written
  byType: Record<string, number>; // Count per entity type
}
```

Follow validate/types.ts patterns for consistency. Export all types.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>Types module exists with FixOptions, FileOperation, FixResult, FixSummary exported</done>
</task>

<task type="auto">
  <name>Task 2: Create ID generator with collision detection</name>
  <files>src/cli/fix/id-generator.ts</files>
  <action>
Create ID generator following CONTEXT.md decisions:

1. `slugifyFilename(filename: string): string`
   - Remove .md extension
   - Lowercase
   - Replace non-alphanumeric with hyphens
   - Remove leading/trailing hyphens
   - Example: "John Smith.md" -> "john-smith"

2. `collectExistingIds(vaultPath: string): Promise<Set<string>>`
   - Use ValidationScanner to find all markdown files
   - Parse frontmatter with gray-matter
   - Extract `id` field from each file
   - Return Set of existing IDs

3. `generateUniqueId(filename: string, entityType: string, existingIds: Set<string>): string`
   - Generate base ID from slugified filename
   - If base ID not in existingIds, return it
   - If collision, prepend entityType: `${entityType}-${baseId}`
   - If still collision, add counter: `${entityType}-${baseId}-2`, `${entityType}-${baseId}-3`, etc.
   - Add generated ID to existingIds set (for subsequent calls in batch)

Example flow:
- "John Doe.md" -> "john-doe" (no collision)
- "John Doe.md" again -> "character-john-doe" (with entityType prefix)
- Third collision -> "character-john-doe-2"
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>ID generator creates unique slugified IDs with collision detection</done>
</task>

<task type="auto">
  <name>Task 3: Create FileFixer class</name>
  <files>src/cli/fix/fixer.ts</files>
  <action>
Create FileFixer class that coordinates fix operations:

```typescript
import { ValidationScanner } from '../validate/scanner.js';
import { templateRegistry } from '../../templates/registry.js';
import { FolderMapper } from '../../templates/folder-mapper.js';
import { initializeTemplateRegistry } from '../validate/validator.js';
import matter from 'gray-matter';
import { collectExistingIds, generateUniqueId, slugifyFilename } from './id-generator.js';
import type { FixOptions, FileOperation } from './types.js';

export class FileFixer {
  private options: FixOptions;
  private folderMapper: FolderMapper | null = null;
  private existingIds: Set<string> = new Set();

  constructor(options: FixOptions) {
    this.options = options;
  }

  /**
   * Initialize template registry and folder mapper.
   */
  async initialize(activeTemplate: string): Promise<void> {
    await initializeTemplateRegistry(activeTemplate);
    const template = templateRegistry.getActive();
    this.folderMapper = await FolderMapper.createFromTemplate(template?.folderMappings);
    this.existingIds = await collectExistingIds(this.options.vaultPath);
  }

  /**
   * Analyze vault and generate fix operations (does not modify files).
   */
  async analyze(): Promise<FileOperation[]>

  /**
   * Generate frontmatter for a file.
   */
  private generateFrontmatter(
    filePath: string,
    entityType: string,
    existingData: Record<string, unknown>
  ): Record<string, unknown>
}
```

Implementation details:
1. `analyze()`:
   - Use ValidationScanner to find files with issues
   - Filter to files with 'missing_frontmatter' or 'missing_field' issues
   - For each file, resolve entity type using FolderMapper
   - If type is ambiguous (multiple types), mark for prompting later
   - Generate FileOperation for each fixable file

2. `generateFrontmatter()`:
   - If file has NO frontmatter: generate full template with required fields
   - If file has partial frontmatter: only add missing required fields
   - Required fields: id, type, status, tags, name
   - Generate ID using generateUniqueId()
   - Set status to 'draft' (per CONTEXT.md)
   - Set name from filename (preserving original case)
   - Preserve existing values (don't overwrite)

Use gray-matter to parse existing frontmatter. Return FileOperation with fieldsToAdd listing only new fields.
  </action>
  <verify>npx tsc --noEmit</verify>
  <done>FileFixer analyzes vault and generates fix operations without modifying files</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. All three modules exist and export correctly
4. FileFixer can analyze a vault directory (manual test optional)
</verification>

<success_criteria>
- Fix types define clear contracts for fix operations
- ID generator handles collisions per CONTEXT.md algorithm
- FileFixer reuses ValidationScanner for file discovery
- FileFixer uses FolderMapper for type resolution
- Partial frontmatter handling preserves existing values
</success_criteria>

<output>
After completion, create `.planning/phases/15-fix-cli/15-01-SUMMARY.md`
</output>
