---
phase: 15-fix-cli
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/fix/types.ts
  - src/cli/fix/fixer.ts
  - src/cli/fix/index.ts
  - tests/cli/fix/integration.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User is prompted for entity type when folder mapping is ambiguous"
    - "Prompt appears once per ambiguous folder (not per file)"
    - "User's type selection applies to all files in that folder"
    - "In --yes mode, first type is used without prompting"
  artifacts:
    - path: "src/cli/fix/types.ts"
      provides: "AmbiguousFile type tracking folder + types"
      contains: "interface AmbiguousFile"
    - path: "src/cli/fix/fixer.ts"
      provides: "Exposes ambiguous files for external prompting"
      contains: "getAmbiguousFiles()"
    - path: "src/cli/fix/index.ts"
      provides: "Interactive type selection using @inquirer/prompts"
      contains: "import { select }"
  key_links:
    - from: "src/cli/fix/index.ts"
      to: "@inquirer/prompts"
      via: "select() for type selection"
      pattern: "await select\\("
    - from: "src/cli/fix/index.ts"
      to: "src/cli/fix/fixer.ts"
      via: "getAmbiguousFiles() and updateOperationType()"
      pattern: "fixer\\.getAmbiguousFiles\\("
---

<objective>
Close verification gap: Implement interactive type selection for ambiguous folder mappings.

Purpose: When a file's folder could map to multiple entity types, the user should be prompted to choose. This enables accurate bulk fixing without manual --type overrides.

Output: Working interactive prompts that appear once per ambiguous folder, with type selection applying to all files in that folder.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-fix-cli/15-CONTEXT.md
@.planning/phases/15-fix-cli/15-VERIFICATION.md

# Existing implementation
@src/cli/fix/types.ts
@src/cli/fix/fixer.ts
@src/cli/fix/index.ts

# Pattern reference
@src/cli/init/prompts.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ambiguous tracking types and update FileFixer</name>
  <files>src/cli/fix/types.ts, src/cli/fix/fixer.ts</files>
  <action>
1. In types.ts, add a new interface after FileOperation:

```typescript
/**
 * Tracks a file with ambiguous type resolution.
 * Used for interactive prompting grouped by folder.
 */
export interface AmbiguousFile {
  /** Path to file (relative to vault) */
  path: string;
  /** Folder path (for grouping prompts) */
  folder: string;
  /** Possible entity types from folder mapping */
  possibleTypes: string[];
}
```

2. In fixer.ts, modify the class to track ambiguous files separately:

- Add private property: `private ambiguousFiles: AmbiguousFile[] = [];`
- Add private property: `private pendingAmbiguous: ValidationResult[] = [];`
- Add getter method: `getAmbiguousFiles(): AmbiguousFile[]` that returns grouped unique folders
- Add method: `resolveAmbiguousType(folder: string, selectedType: string): void` that updates pending files

3. Modify `resolveEntityType()`:
- Remove the "return first type" fallback for ambiguous case when NOT in --yes mode
- Instead, return null and store the file info in pendingAmbiguous
- Keep --yes mode behavior unchanged (uses first type)

4. Add method to process pending ambiguous files after user selection:
```typescript
async processPendingAmbiguous(): Promise<FileOperation[]>
```
This creates operations for files that were previously skipped due to ambiguity.
  </action>
  <verify>
- `npm run build` succeeds
- types.ts exports AmbiguousFile interface
- fixer.ts has getAmbiguousFiles() and resolveAmbiguousType() methods
  </verify>
  <done>
FileFixer exposes ambiguous files for CLI to prompt, and can process them after user selects type
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire interactive prompting in CLI</name>
  <files>src/cli/fix/index.ts</files>
  <action>
1. Uncomment and update the import at line 24:
```typescript
import { select } from '@inquirer/prompts';
import { dirname } from 'path';
```

2. After `fixer.analyze()` call (around line 175), add ambiguous type handling:

```typescript
// 5. Handle ambiguous types (prompt user once per folder)
if (!options.yes && !options.json) {
  const ambiguousFiles = fixer.getAmbiguousFiles();

  // Group by folder (unique folders only)
  const folderGroups = new Map<string, string[]>();
  for (const af of ambiguousFiles) {
    if (!folderGroups.has(af.folder)) {
      folderGroups.set(af.folder, af.possibleTypes);
    }
  }

  // Prompt for each ambiguous folder
  for (const [folder, types] of folderGroups) {
    const selectedType = await select({
      message: `Select entity type for files in "${folder}":`,
      choices: types.map(t => ({ name: t, value: t })),
    });

    fixer.resolveAmbiguousType(folder, selectedType);
  }

  // Process pending files with resolved types
  const additionalOps = await fixer.processPendingAmbiguous();
  operations.push(...additionalOps);
}
```

3. Update comment at line 22-25 to document the feature:
```typescript
// Interactive prompting for ambiguous folder mappings.
// When a folder maps to multiple types, user selects once per folder.
// In --yes or --json mode, first type is used without prompting.
```
  </action>
  <verify>
- `npm run build` succeeds
- Running `npx hivemind fix` on a vault with ambiguous folders prompts for selection
- Running `npx hivemind fix --yes` uses first type without prompting
  </verify>
  <done>
CLI prompts user for type when folder mapping is ambiguous, selection applies to all files in folder
  </done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for ambiguous prompting</name>
  <files>tests/cli/fix/integration.test.ts</files>
  <action>
Add test cases for ambiguous type handling:

1. Test that verifies ambiguous files are detected correctly:
```typescript
describe('ambiguous type handling', () => {
  it('detects files in folders with multiple type mappings', async () => {
    // Setup vault with folder that maps to multiple types
    // (requires custom config with ambiguous mapping)
    // Verify getAmbiguousFiles() returns expected files
  });
});
```

2. Test --yes mode behavior (existing behavior, verify it still works):
```typescript
it('uses first type in --yes mode for ambiguous folders', async () => {
  // Create vault with ambiguous folder
  // Run with --yes
  // Verify first type is used
});
```

3. Test that resolved type applies to all files in folder:
```typescript
it('applies selected type to all files in folder', async () => {
  // Create fixer, analyze, get ambiguous files
  // Call resolveAmbiguousType for a folder
  // Call processPendingAmbiguous
  // Verify all files in that folder use selected type
});
```

Note: Interactive prompt testing is difficult without mocking. Focus on testing the FileFixer API:
- getAmbiguousFiles() returns correct data
- resolveAmbiguousType() + processPendingAmbiguous() workflow works
- --yes mode skips ambiguous detection
  </action>
  <verify>
- `npm test` passes all tests including new ambiguous handling tests
- Tests verify the FileFixer API for ambiguous files
  </verify>
  <done>
Test coverage for ambiguous type detection and resolution workflow
  </done>
</task>

</tasks>

<verification>
1. Build succeeds: `npm run build`
2. Tests pass: `npm test`
3. Manual verification:
   - Create vault with folder mapping that has multiple types (or manually edit config)
   - Run `npx hivemind fix` - should prompt for type selection
   - Run `npx hivemind fix --yes` - should use first type without prompting
   - Verify selection applies to all files in the folder
</verification>

<success_criteria>
- User is prompted when folder mapping is ambiguous (not in --yes mode)
- Prompt appears once per folder, not per file
- Selected type applies to all files in that folder
- --yes mode continues to use first type without prompting
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/15-fix-cli/15-04-SUMMARY.md`
</output>
