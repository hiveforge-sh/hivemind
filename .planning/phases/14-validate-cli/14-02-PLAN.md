---
phase: 14-validate-cli
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/cli/validate/formatter.ts
  - src/cli/validate/index.ts
  - src/cli.ts
autonomous: true

must_haves:
  truths:
    - "User runs `npx hivemind validate` and sees grouped output by issue type"
    - "User runs `npx hivemind validate --json` and gets machine-parseable JSON"
    - "Silent success - no output when validation passes (exit code 0)"
    - "Exit code 1 for validation errors, exit code 2 for config errors"
  artifacts:
    - path: "src/cli/validate/formatter.ts"
      provides: "Text and JSON output formatting"
      exports: ["formatTextOutput", "formatJsonOutput", "formatIssueMessage"]
    - path: "src/cli/validate/index.ts"
      provides: "CLI command entry point with argument parsing"
      exports: ["validateCommand"]
    - path: "src/cli.ts"
      provides: "Updated CLI with validate command wired in"
      contains: "validateCommand"
  key_links:
    - from: "src/cli.ts"
      to: "src/cli/validate/index.ts"
      via: "imports and calls validateCommand"
      pattern: "import.*validateCommand"
    - from: "src/cli/validate/index.ts"
      to: "src/cli/validate/scanner.ts"
      via: "creates scanner and runs validation"
      pattern: "ValidationScanner"
    - from: "src/cli/validate/index.ts"
      to: "src/cli/validate/formatter.ts"
      via: "formats results for output"
      pattern: "formatTextOutput|formatJsonOutput"
---

<objective>
Create output formatters and wire the validate command into the CLI.

Purpose: Users can run `npx hivemind validate` and see useful, grouped output about vault issues. JSON output enables CI integration.

Output: formatter.ts (text/JSON formatting), index.ts (CLI entry point), updated cli.ts
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-validate-cli/14-CONTEXT.md
@.planning/phases/14-validate-cli/14-RESEARCH.md
@.planning/phases/14-validate-cli/14-01-SUMMARY.md

# Relevant source files
@src/cli/validate/types.ts - Validation types (from 14-01)
@src/cli/validate/scanner.ts - File scanner (from 14-01)
@src/cli/validate/validator.ts - File validator (from 14-01)
@src/cli.ts - Main CLI entry point
@src/cli/init/index.ts - CLI command patterns (argument parsing)
@src/cli/init/output.ts - Output patterns (outputMissingConfigError)
@src/cli/shared/colors.ts - Color utilities (success, error, dim, bold)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create output formatter module</name>
  <files>src/cli/validate/formatter.ts</files>
  <action>
Create formatter.ts with text and JSON output formatters following CONTEXT.md decisions.

Implementation:
1. Import types from `./types.js`
2. Import colors from `../shared/colors.js`

Create `formatIssueMessage` helper:
```typescript
export function formatIssueMessage(issue: ValidationIssue): string {
  switch (issue.type) {
    case 'missing_frontmatter':
      return 'Missing frontmatter';
    case 'missing_field':
      return `Missing required field: ${issue.field}`;
    case 'invalid_type':
      return `Invalid type "${issue.actual}" (valid: ${issue.validTypes.join(', ')})`;
    case 'schema_error':
      return `${issue.field}: ${issue.message}`;
    case 'folder_mismatch':
      return `Folder suggests type "${issue.expected}" but file has type "${issue.actual}"`;
  }
}
```

Create `formatTextOutput` - grouped by issue type:
```typescript
export function formatTextOutput(results: ValidationResult[], summary: ValidationSummary): string {
  // Group results by issue type
  const groups = {
    missing_frontmatter: results.filter(r => r.issues.some(i => i.type === 'missing_frontmatter')),
    invalid_type: results.filter(r => r.issues.some(i => i.type === 'invalid_type')),
    missing_field: results.filter(r => r.issues.some(i => i.type === 'missing_field')),
    schema_error: results.filter(r => r.issues.some(i => i.type === 'schema_error')),
    folder_mismatch: results.filter(r => r.issues.some(i => i.type === 'folder_mismatch')),
  };

  const output: string[] = [];

  // Output each group with header
  if (groups.missing_frontmatter.length > 0) {
    output.push(error('Missing frontmatter:'));
    for (const result of groups.missing_frontmatter) {
      output.push(`  ${result.path}`);
    }
    output.push('');
  }

  // ... similar for other groups

  // Summary line at end (always shown if there are issues)
  const totalIssues = Object.values(summary.issuesByType).reduce((a, b) => a + b, 0);
  output.push(`Found ${totalIssues} issues in ${summary.invalidFiles} files`);

  return output.join('\n');
}
```

Create `formatJsonOutput` - grouped by file per CONTEXT.md:
```typescript
export function formatJsonOutput(
  results: ValidationResult[],
  summary: ValidationSummary,
  vaultPath: string
): string {
  const files: Record<string, string[]> = {};

  for (const result of results) {
    if (!result.valid) {
      files[result.path] = result.issues.map(formatIssueMessage);
    }
  }

  const output = {
    valid: summary.invalidFiles === 0,
    timestamp: new Date().toISOString(),
    vaultPath,
    totalFiles: summary.totalFiles,
    totalIssues: Object.values(summary.issuesByType).reduce((a, b) => a + b, 0),
    files,
    summary: {
      missingFrontmatter: summary.issuesByType.missing_frontmatter || 0,
      invalidType: summary.issuesByType.invalid_type || 0,
      missingField: summary.issuesByType.missing_field || 0,
      schemaErrors: summary.issuesByType.schema_error || 0,
      folderMismatches: summary.issuesByType.folder_mismatch || 0,
    }
  };

  return JSON.stringify(output, null, 2);
}
```

Create `calculateSummary` helper:
```typescript
export function calculateSummary(results: ValidationResult[]): ValidationSummary {
  // Count files and issues by type
}
```
  </action>
  <verify>
    - File exists at src/cli/validate/formatter.ts
    - `npx tsc --noEmit` passes
    - formatTextOutput, formatJsonOutput, formatIssueMessage are exported
  </verify>
  <done>Text output groups by issue type, JSON output groups by file, summary calculation works</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI validate command entry point</name>
  <files>src/cli/validate/index.ts</files>
  <action>
Create index.ts as the entry point for `npx hivemind validate` command.

Implementation:
1. Import ValidationScanner, formatter functions, types
2. Import outputMissingConfigError from `../init/output.js`
3. Import config loading utilities

Create `parseValidateArgs` function:
```typescript
function parseValidateArgs(): ValidateOptions {
  const args = process.argv.slice(3); // Skip node, script, 'validate'
  const options: ValidateOptions = {
    vaultPath: '', // Will be set from config
    skipMissing: args.includes('--skip-missing'),
    ignorePatterns: [],
    json: args.includes('--json'),
    quiet: args.includes('--quiet'),
  };

  // Parse --ignore patterns (can appear multiple times)
  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--ignore' && args[i + 1]) {
      options.ignorePatterns!.push(args[i + 1]);
    }
  }

  // Parse target path (non-flag argument)
  const nonFlagArgs = args.filter(a => !a.startsWith('-') &&
    args[args.indexOf(a) - 1] !== '--ignore');
  if (nonFlagArgs.length > 0) {
    options.targetPath = nonFlagArgs[0];
  }

  return options;
}
```

Create `validateCommand` function:
```typescript
export async function validateCommand(): Promise<void> {
  // 1. Load config
  const configPath = resolve(process.cwd(), 'config.json');
  if (!existsSync(configPath)) {
    outputMissingConfigError();
    process.exit(2); // Config error
  }

  let config: any;
  try {
    config = JSON.parse(readFileSync(configPath, 'utf-8'));
  } catch (err) {
    console.error('Configuration error:', err.message);
    process.exit(2);
  }

  // 2. Get vault path
  const vaultPath = resolve(config.vault?.path);
  if (!vaultPath || !existsSync(vaultPath)) {
    console.error('Vault path does not exist:', vaultPath);
    process.exit(2);
  }

  // 3. Parse arguments
  const options = parseValidateArgs();
  options.vaultPath = vaultPath;

  // 4. Initialize template registry
  const activeTemplate = config.template?.activeTemplate || 'worldbuilding';
  await initializeTemplateRegistry(activeTemplate);

  // 5. Run scanner
  const scanner = new ValidationScanner(options);
  const results = await scanner.scan();
  const summary = calculateSummary(results);

  // 6. Output results based on flags
  if (summary.invalidFiles === 0) {
    // Silent success per CONTEXT.md
    process.exit(0);
  }

  if (!options.quiet) {
    if (options.json) {
      console.log(formatJsonOutput(results, summary, vaultPath));
    } else {
      console.log(formatTextOutput(results, summary));

      // ERR-03: Suggestions when vault has no valid entities
      if (summary.validFiles === 0 && summary.totalFiles > 0) {
        console.log('');
        console.log('Your vault has no files with valid frontmatter.');
        console.log('Try:');
        console.log('  1. Run "npx hivemind fix" to add frontmatter to existing files');
        console.log('  2. Check that your templates match your content types');
        console.log('  3. Run "npx hivemind init" to reconfigure if needed');
      }
    }
  }

  process.exit(1); // Validation errors found
}
```
  </action>
  <verify>
    - File exists at src/cli/validate/index.ts
    - `npx tsc --noEmit` passes
    - validateCommand function is exported
    - Exit codes: 0 success, 1 validation errors, 2 config errors
  </verify>
  <done>validateCommand handles config loading, argument parsing, scanner invocation, and output formatting with correct exit codes</done>
</task>

<task type="auto">
  <name>Task 3: Wire validate command into CLI</name>
  <files>src/cli.ts</files>
  <action>
Update cli.ts to import and wire the validate command.

Changes:
1. Add import at top:
   ```typescript
   import { validateCommand } from './cli/validate/index.js';
   ```

2. Update the switch statement for 'validate' case:
   ```typescript
   case 'validate':
     validateCommand();
     break;
   ```
   (Replace the existing validate() function call with validateCommand())

3. Update the help text to show validate flags:
   ```
   npx @hiveforge/hivemind-mcp validate [path]         - Validate vault frontmatter
     --json           Output machine-readable JSON
     --quiet          Suppress output, only set exit code
     --skip-missing   Skip files without frontmatter
     --ignore <glob>  Exclude files matching pattern
   ```

4. Remove the old validate() function (lines 281-386) since it's replaced by the new module.

Note: The old validate() function does config validation, not vault validation. The new validateCommand() does vault frontmatter validation per requirements. Keep the help output updated to reflect the new behavior.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx hivemind validate --help` shows new flags in help output
    - Old validate() function removed, replaced with validateCommand import
  </verify>
  <done>CLI wires to new validateCommand, help shows validate flags, old config-only validate removed</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - TypeScript compilation passes
2. `npm run build` - Builds successfully
3. Manual test with a vault:
   - `npx hivemind validate` - Should work with no errors
   - `npx hivemind validate --json` - Should output JSON
   - Exit codes match requirements (0 success, 1 validation errors, 2 config errors)
</verification>

<success_criteria>
- VALD-01: validate scans vault for missing frontmatter (grouped output)
- VALD-02: validate reports invalid frontmatter (grouped output)
- VALD-03: validate uses template schemas (via SchemaFactory integration)
- VALD-04: exit code 0 success, 1 validation errors, 2 config errors
- VALD-05: --json outputs machine-parseable results
- ERR-03: Suggestions when vault has no valid entities
</success_criteria>

<output>
After completion, create `.planning/phases/14-validate-cli/14-02-SUMMARY.md`
</output>
