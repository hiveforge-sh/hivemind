---
phase: 14-validate-cli
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/validate/types.ts
  - src/cli/validate/scanner.ts
  - src/cli/validate/validator.ts
autonomous: true

must_haves:
  truths:
    - "Markdown files in vault can be discovered with exclusion support"
    - "Frontmatter can be parsed and validated against template schemas"
    - "Issues are classified by type (missing, invalid type, schema error, folder mismatch)"
  artifacts:
    - path: "src/cli/validate/types.ts"
      provides: "ValidationResult, ValidationIssue, and supporting types"
      exports: ["ValidationResult", "ValidationIssue", "ValidationSummary"]
    - path: "src/cli/validate/scanner.ts"
      provides: "File discovery that finds markdown files with exclusion support"
      exports: ["ValidationScanner"]
    - path: "src/cli/validate/validator.ts"
      provides: "Frontmatter validation using template schemas"
      exports: ["validateFile", "initializeTemplateRegistry"]
  key_links:
    - from: "src/cli/validate/scanner.ts"
      to: "src/cli/validate/validator.ts"
      via: "scanner calls validateFile for each discovered file"
      pattern: "validateFile\\(filePath"
    - from: "src/cli/validate/validator.ts"
      to: "src/templates/registry.ts"
      via: "validates against active template's entity types"
      pattern: "templateRegistry\\.getActive"
---

<objective>
Create the validation infrastructure modules for the `npx hivemind validate` CLI command.

Purpose: Establish the core types, file scanning, and validation logic needed for vault validation. This is the foundation that formatters and CLI integration will build upon.

Output: Three modules - types.ts (data structures), scanner.ts (file discovery), validator.ts (frontmatter validation)
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-validate-cli/14-CONTEXT.md
@.planning/phases/14-validate-cli/14-RESEARCH.md

# Relevant source files
@src/vault/reader.ts - File discovery patterns (findMarkdownFiles, shouldExclude)
@src/templates/registry.ts - Template registry access patterns
@src/templates/schema-factory.ts - Zod schema generation from entity config
@src/templates/folder-mapper.ts - Type inference from file paths
@src/parser/markdown.ts - Frontmatter parsing with gray-matter
@src/cli/init/index.ts - CLI command patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation types module</name>
  <files>src/cli/validate/types.ts</files>
  <action>
Create types.ts with all data structures for validation results.

Required types:
1. `ValidationIssue` - Discriminated union for different issue types:
   - `missing_frontmatter`: File has no frontmatter at all
   - `missing_field`: Required field is missing (field: string)
   - `invalid_type`: Type field doesn't match any template entity type (actual: string, validTypes: string[])
   - `schema_error`: Zod validation failed (field: string, message: string)
   - `folder_mismatch`: File location doesn't match declared type (expected: string, actual: string, matchedPattern: string)

2. `ValidationResult` - Result for a single file:
   - path: string (relative to vault)
   - valid: boolean
   - issues: ValidationIssue[]
   - frontmatter?: Record<string, unknown> (included for debugging)

3. `ValidationSummary` - Aggregate statistics:
   - totalFiles: number
   - validFiles: number
   - invalidFiles: number
   - issuesByType: Record<ValidationIssue['type'], number>

4. `ValidateOptions` - CLI options:
   - vaultPath: string
   - skipMissing?: boolean (--skip-missing flag)
   - ignorePatterns?: string[] (--ignore patterns)
   - targetPath?: string (optional specific file/folder)
   - json?: boolean (--json output)
   - quiet?: boolean (--quiet, only exit code)

Export all types for use by other modules.
  </action>
  <verify>
    - File exists at src/cli/validate/types.ts
    - `npx tsc --noEmit` passes
    - Types are exported and can be imported
  </verify>
  <done>ValidationIssue, ValidationResult, ValidationSummary, and ValidateOptions types defined with discriminated union for issue classification</done>
</task>

<task type="auto">
  <name>Task 2: Create validation scanner module</name>
  <files>src/cli/validate/scanner.ts</files>
  <action>
Create scanner.ts that discovers markdown files in the vault with exclusion support.

Implementation:
1. Import `ValidateOptions`, `ValidationResult` from `./types.js`
2. Import `validateFile` from `./validator.js`

Create `ValidationScanner` class:
```typescript
export class ValidationScanner {
  private options: ValidateOptions;

  constructor(options: ValidateOptions) { ... }

  async scan(): Promise<ValidationResult[]> {
    // Determine starting path (targetPath or vaultPath)
    // Find all markdown files recursively
    // Apply exclusion patterns (default + user-provided)
    // Call validateFile for each file
    // Return array of ValidationResult
  }
}
```

File discovery logic (adapt from VaultReader patterns):
- Default exclusions: `.obsidian`, `.trash`, `.git`, `node_modules`
- Support user-provided ignorePatterns (glob patterns via picomatch)
- Skip hidden files/folders (starting with `.`)
- Handle targetPath: if provided, validate only that file or folder
- Use `relative(vaultPath, filePath)` for consistent path output

Error handling:
- If a file can't be read, include it in results with an error issue
- Continue scanning even if individual files fail
  </action>
  <verify>
    - File exists at src/cli/validate/scanner.ts
    - `npx tsc --noEmit` passes
    - ValidationScanner class is exported
  </verify>
  <done>ValidationScanner discovers all markdown files with exclusion support and delegates to validator</done>
</task>

<task type="auto">
  <name>Task 3: Create frontmatter validator module</name>
  <files>src/cli/validate/validator.ts</files>
  <action>
Create validator.ts that validates individual files against template schemas.

Implementation:
1. Import gray-matter for frontmatter parsing
2. Import templateRegistry from `../../templates/registry.js`
3. Import FolderMapper from `../../templates/folder-mapper.js`
4. Import schemaFactory from `../../templates/schema-factory.js`
5. Import builtin templates for registration

Create `initializeTemplateRegistry` function:
```typescript
export async function initializeTemplateRegistry(activeTemplate: string): Promise<void> {
  // Register builtin templates if not already registered
  // Activate the specified template
  // Same pattern as cli.ts fix() function
}
```

Create `validateFile` function:
```typescript
export async function validateFile(
  filePath: string,
  vaultPath: string,
  options: Pick<ValidateOptions, 'skipMissing'>
): Promise<ValidationResult> {
  const issues: ValidationIssue[] = [];

  // 1. Read file content
  const content = await fs.readFile(filePath, 'utf-8');

  // 2. Parse frontmatter with gray-matter
  const { data: frontmatter } = matter(content);

  // 3. Check for missing frontmatter
  if (!frontmatter || Object.keys(frontmatter).length === 0) {
    if (options.skipMissing) {
      return { path, valid: true, issues: [] }; // Skip this file
    }
    return { path, valid: false, issues: [{ type: 'missing_frontmatter' }] };
  }

  // 4. Check for missing required base fields (id, type, status)
  // Add missing_field issues for each

  // 5. Validate type against template entity types
  // If type not found, add invalid_type issue

  // 6. If type is valid, validate against entity schema
  // Use schemaFactory to get the schema for this entity type
  // Add schema_error issues for each Zod validation failure

  // 7. Check folder mismatch (optional warning)
  // Use FolderMapper to infer expected type from path
  // If inferred type differs from declared type, add folder_mismatch issue

  return {
    path: relative(vaultPath, filePath),
    valid: issues.length === 0,
    issues,
    frontmatter
  };
}
```

Important notes:
- Use `relative(vaultPath, filePath)` to normalize paths
- SchemaFactory caches schemas, so safe to call repeatedly
- FolderMapper requires async initialization - create once and reuse
- Handle Zod validation errors gracefully, extracting path and message
  </action>
  <verify>
    - File exists at src/cli/validate/validator.ts
    - `npx tsc --noEmit` passes
    - Both validateFile and initializeTemplateRegistry are exported
  </verify>
  <done>validateFile parses frontmatter and validates against template schemas with issue classification</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` - TypeScript compilation passes
2. All three modules exist in src/cli/validate/
3. Types are properly exported and can be imported
4. Code follows existing CLI patterns from cli/init/
</verification>

<success_criteria>
- ValidationScanner can discover markdown files with exclusion support
- validateFile can parse frontmatter and validate against template schemas
- Issues are classified into appropriate types (missing_frontmatter, missing_field, invalid_type, schema_error, folder_mismatch)
- Template registry initialization follows established patterns
</success_criteria>

<output>
After completion, create `.planning/phases/14-validate-cli/14-01-SUMMARY.md`
</output>
