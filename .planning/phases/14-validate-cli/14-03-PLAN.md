---
phase: 14-validate-cli
plan: 03
type: tdd
wave: 3
depends_on: ["14-02"]
files_modified:
  - tests/cli/validate/scanner.test.ts
  - tests/cli/validate/validator.test.ts
  - tests/cli/validate/formatter.test.ts
  - tests/cli/validate/integration.test.ts
autonomous: true

must_haves:
  truths:
    - "Scanner discovers markdown files with exclusion support"
    - "Validator correctly classifies all issue types"
    - "Text formatter groups output by issue type"
    - "JSON formatter produces valid JSON grouped by file"
    - "Integration test validates end-to-end behavior"
  artifacts:
    - path: "tests/cli/validate/scanner.test.ts"
      provides: "Unit tests for ValidationScanner"
      min_lines: 50
    - path: "tests/cli/validate/validator.test.ts"
      provides: "Unit tests for validateFile"
      min_lines: 80
    - path: "tests/cli/validate/formatter.test.ts"
      provides: "Unit tests for text and JSON formatters"
      min_lines: 60
    - path: "tests/cli/validate/integration.test.ts"
      provides: "Integration tests for full validation flow"
      min_lines: 80
  key_links:
    - from: "tests/cli/validate/validator.test.ts"
      to: "src/cli/validate/validator.ts"
      via: "tests validateFile function"
      pattern: "validateFile"
    - from: "tests/cli/validate/integration.test.ts"
      to: "src/cli/validate/index.ts"
      via: "tests full command flow"
      pattern: "ValidationScanner|validateCommand"
---

<objective>
Create comprehensive tests for the validate command modules.

Purpose: Ensure validation logic correctly identifies all issue types, formatters produce expected output, and end-to-end flow works correctly.

Output: Test files covering scanner, validator, formatter, and integration scenarios
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-validate-cli/14-CONTEXT.md
@.planning/phases/14-validate-cli/14-01-SUMMARY.md
@.planning/phases/14-validate-cli/14-02-SUMMARY.md

# Source files to test
@src/cli/validate/types.ts
@src/cli/validate/scanner.ts
@src/cli/validate/validator.ts
@src/cli/validate/formatter.ts
@src/cli/validate/index.ts

# Test patterns
@tests/cli/validate-template.test.ts - CLI test patterns
@tests/templates/folder-mapper.test.ts - Test patterns with fixtures
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validator tests</name>
  <files>tests/cli/validate/validator.test.ts</files>
  <action>
Create validator.test.ts testing validateFile function and issue classification.

Test setup:
1. Import validateFile, initializeTemplateRegistry
2. Use vitest (describe, it, expect, beforeAll, afterAll)
3. Create temp files with various frontmatter scenarios
4. Initialize template registry before tests

Test cases (following TDD - write failing test, implement to pass):

**Missing frontmatter:**
```typescript
it('detects missing frontmatter', async () => {
  // Create temp file with no frontmatter
  const result = await validateFile(tempFile, tempDir, {});
  expect(result.valid).toBe(false);
  expect(result.issues[0].type).toBe('missing_frontmatter');
});
```

**Missing required fields:**
```typescript
it('detects missing required field', async () => {
  // Create file with frontmatter missing 'id' field
  const result = await validateFile(tempFile, tempDir, {});
  expect(result.issues.some(i => i.type === 'missing_field' && i.field === 'id')).toBe(true);
});
```

**Invalid type:**
```typescript
it('detects invalid entity type', async () => {
  // Create file with type: 'invalid_type'
  const result = await validateFile(tempFile, tempDir, {});
  expect(result.issues.some(i => i.type === 'invalid_type')).toBe(true);
});
```

**Schema errors:**
```typescript
it('detects schema validation errors', async () => {
  // Create file with invalid value for a required schema field
  const result = await validateFile(tempFile, tempDir, {});
  expect(result.issues.some(i => i.type === 'schema_error')).toBe(true);
});
```

**Valid file:**
```typescript
it('reports valid for correctly formatted file', async () => {
  // Create file with complete valid frontmatter
  const result = await validateFile(tempFile, tempDir, {});
  expect(result.valid).toBe(true);
  expect(result.issues).toHaveLength(0);
});
```

**skipMissing flag:**
```typescript
it('skips files without frontmatter when skipMissing is true', async () => {
  // File with no frontmatter
  const result = await validateFile(tempFile, tempDir, { skipMissing: true });
  expect(result.valid).toBe(true);
});
```
  </action>
  <verify>
    - `npm test -- tests/cli/validate/validator.test.ts` passes
    - All issue types have at least one test
  </verify>
  <done>Validator tests cover all issue types and skipMissing flag</done>
</task>

<task type="auto">
  <name>Task 2: Create scanner and formatter tests</name>
  <files>tests/cli/validate/scanner.test.ts, tests/cli/validate/formatter.test.ts</files>
  <action>
Create scanner.test.ts testing file discovery:

Test cases:
```typescript
describe('ValidationScanner', () => {
  it('discovers markdown files recursively', async () => {
    // Create temp vault with nested .md files
    const scanner = new ValidationScanner({ vaultPath: tempDir });
    const results = await scanner.scan();
    expect(results.length).toBeGreaterThan(0);
  });

  it('excludes hidden directories', async () => {
    // Create .hidden/file.md
    const scanner = new ValidationScanner({ vaultPath: tempDir });
    const results = await scanner.scan();
    expect(results.some(r => r.path.includes('.hidden'))).toBe(false);
  });

  it('excludes .obsidian folder', async () => {
    // Create .obsidian/plugins.md
    const scanner = new ValidationScanner({ vaultPath: tempDir });
    const results = await scanner.scan();
    expect(results.some(r => r.path.includes('.obsidian'))).toBe(false);
  });

  it('applies custom ignore patterns', async () => {
    // Create templates/note.md
    const scanner = new ValidationScanner({
      vaultPath: tempDir,
      ignorePatterns: ['templates/**']
    });
    const results = await scanner.scan();
    expect(results.some(r => r.path.includes('templates'))).toBe(false);
  });

  it('validates specific target path', async () => {
    // Create Characters/alice.md and Locations/town.md
    const scanner = new ValidationScanner({
      vaultPath: tempDir,
      targetPath: 'Characters'
    });
    const results = await scanner.scan();
    expect(results.every(r => r.path.startsWith('Characters'))).toBe(true);
  });
});
```

Create formatter.test.ts testing output formatting:

```typescript
describe('formatTextOutput', () => {
  it('groups results by issue type', () => {
    const results = [
      { path: 'a.md', valid: false, issues: [{ type: 'missing_frontmatter' }] },
      { path: 'b.md', valid: false, issues: [{ type: 'invalid_type', actual: 'foo', validTypes: ['bar'] }] },
    ];
    const summary = calculateSummary(results);
    const output = formatTextOutput(results, summary);
    expect(output).toContain('Missing frontmatter:');
    expect(output).toContain('Invalid entity type:');
  });

  it('shows summary line with totals', () => {
    const results = [...];
    const summary = calculateSummary(results);
    const output = formatTextOutput(results, summary);
    expect(output).toMatch(/Found \d+ issues in \d+ files/);
  });
});

describe('formatJsonOutput', () => {
  it('produces valid JSON', () => {
    const results = [...];
    const summary = calculateSummary(results);
    const output = formatJsonOutput(results, summary, '/vault');
    expect(() => JSON.parse(output)).not.toThrow();
  });

  it('groups issues by file path', () => {
    const results = [...];
    const summary = calculateSummary(results);
    const json = JSON.parse(formatJsonOutput(results, summary, '/vault'));
    expect(json.files).toBeDefined();
    expect(Object.keys(json.files).length).toBe(summary.invalidFiles);
  });

  it('includes summary counts', () => {
    const results = [...];
    const summary = calculateSummary(results);
    const json = JSON.parse(formatJsonOutput(results, summary, '/vault'));
    expect(json.summary).toBeDefined();
    expect(json.summary.missingFrontmatter).toBeDefined();
  });
});
```
  </action>
  <verify>
    - `npm test -- tests/cli/validate/scanner.test.ts` passes
    - `npm test -- tests/cli/validate/formatter.test.ts` passes
  </verify>
  <done>Scanner tests verify file discovery and exclusions, formatter tests verify grouped output and JSON structure</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests</name>
  <files>tests/cli/validate/integration.test.ts</files>
  <action>
Create integration.test.ts testing full validation flow.

Test cases:
```typescript
describe('validate command integration', () => {
  it('exits 0 for vault with all valid files', async () => {
    // Create temp vault with valid frontmatter files
    // Run validateCommand() - should exit 0
    // (mock process.exit to capture code)
  });

  it('exits 1 for vault with validation errors', async () => {
    // Create temp vault with some invalid files
    // Run validateCommand() - should exit 1
  });

  it('produces JSON output with --json flag', async () => {
    // Create temp vault with issues
    // Run with json: true option
    // Verify output is valid JSON
  });

  it('produces no output when valid and quiet', async () => {
    // Create temp vault with all valid files
    // Run with quiet: true
    // Verify no console output
  });

  it('shows helpful suggestions when no valid entities (ERR-03)', async () => {
    // Create temp vault where ALL files have issues
    // Run validate
    // Verify output contains suggestion text
  });

  it('uses template schemas for validation (VALD-03)', async () => {
    // Create file with type that exists in template
    // Create file with custom field that violates schema
    // Verify schema_error is detected
  });
});
```

Test utilities:
- Create helper to set up temp vault with specific files
- Mock process.exit to capture exit codes
- Capture console.log output for assertions
- Clean up temp directories after tests
  </action>
  <verify>
    - `npm test -- tests/cli/validate/integration.test.ts` passes
    - All requirements covered (VALD-01 through VALD-05, ERR-03)
  </verify>
  <done>Integration tests verify end-to-end behavior and all requirements</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm test -- tests/cli/validate/` - All validate tests pass
2. `npm test` - Full test suite passes (no regressions)
3. Test coverage for each requirement:
   - VALD-01: scanner tests + integration
   - VALD-02: validator tests + integration
   - VALD-03: validator tests (schema_error)
   - VALD-04: integration tests (exit codes)
   - VALD-05: formatter tests (JSON output)
   - ERR-03: integration test (suggestions)
</verification>

<success_criteria>
- All tests pass with `npm test`
- Each validation issue type has test coverage
- Scanner exclusion patterns are tested
- Both output formats (text/JSON) are tested
- Exit codes are verified in integration tests
- ERR-03 suggestion output is tested
</success_criteria>

<output>
After completion, create `.planning/phases/14-validate-cli/14-03-SUMMARY.md`
</output>
