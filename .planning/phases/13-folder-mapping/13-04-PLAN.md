---
phase: 13-folder-mapping
plan: 04
type: execute
wave: 1
depends_on: ["13-03"]
files_modified:
  - src/templates/registry.ts
  - obsidian-plugin/main.ts
  - src/cli.ts
  - tests/templates/folder-mapper.test.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can configure folder mappings in config.json and they are used at runtime"
    - "Active template's folderMappings flow to FolderMapper in both CLI and Obsidian plugin"
    - "Templates without explicit folderMappings fall back to worldbuilding defaults"
  artifacts:
    - path: "src/templates/registry.ts"
      provides: "getFolderMappings() method to retrieve active template's folder mappings"
      contains: "getFolderMappings"
    - path: "obsidian-plugin/main.ts"
      provides: "Folder mapper initialized from template config (not hardcoded defaults)"
      contains: "templateRegistry.getFolderMappings()"
    - path: "src/cli.ts"
      provides: "Uses async FolderMapper with template config instead of LegacyFolderMapper"
      contains: "FolderMapper.createFromTemplate"
    - path: "tests/templates/folder-mapper.test.ts"
      provides: "Integration test verifying template folderMappings flow"
      contains: "createFromTemplate"
  key_links:
    - from: "src/templates/registry.ts"
      to: "src/templates/types.ts"
      via: "getFolderMappings() returns FolderMappingRule[]"
      pattern: "getFolderMappings.*FolderMappingRule"
    - from: "obsidian-plugin/main.ts"
      to: "src/templates/registry.ts"
      via: "imports and uses templateRegistry.getFolderMappings()"
      pattern: "templateRegistry\\.getFolderMappings"
    - from: "src/cli.ts"
      to: "src/templates/folder-mapper.ts"
      via: "uses FolderMapper.createFromTemplate()"
      pattern: "FolderMapper\\.createFromTemplate"
---

<objective>
Wire folder mappings from template config to runtime consumers (CLI and Obsidian plugin).

Purpose: Close the final gap where infrastructure exists but consumers ignore template configuration. After this plan, users CAN configure folder mappings in config.json and those mappings WILL be used.

Output:
- templateRegistry.getFolderMappings() method for accessing active template's mappings
- Obsidian plugin wired to use template config instead of defaults
- CLI fix command using async FolderMapper with template config
- Integration test verifying end-to-end flow
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-folder-mapping/13-VERIFICATION.md
@.planning/phases/13-folder-mapping/13-03-SUMMARY.md

# Source files to modify
@src/templates/registry.ts
@obsidian-plugin/main.ts
@src/cli.ts

# Reference: existing infrastructure
@src/templates/folder-mapper.ts
@src/templates/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add getFolderMappings() accessor to TemplateRegistry</name>
  <files>src/templates/registry.ts</files>
  <action>
Add a new public method to TemplateRegistry class that retrieves folder mappings from the active template.

1. Add import for FolderMappingRule type at the top:
   ```typescript
   import type {
     TemplateDefinition,
     TemplateRegistryEntry,
     EntityTypeConfig,
     RelationshipTypeConfig,
     FolderMappingRule,
   } from './types.js';
   ```

2. Add getFolderMappings() method after getRelationshipTypes() (around line 198):
   ```typescript
   /**
    * Gets folder mappings from the active template.
    *
    * Returns the template's configured folder mappings for entity type inference.
    * Returns undefined if the template has no folder mappings defined.
    *
    * @returns Array of folder mapping rules, or undefined if not configured
    * @throws {Error} If no template is active
    */
   getFolderMappings(): FolderMappingRule[] | undefined {
     const active = this.getActive();
     if (!active) {
       throw new Error('Cannot get folder mappings: no active template');
     }
     return active.folderMappings;
   }
   ```

This method follows the same pattern as getEntityTypes() and getRelationshipTypes() - throws if no active template, returns the field value (undefined if not set).
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- grep "getFolderMappings" src/templates/registry.ts shows the new method
- The method returns FolderMappingRule[] | undefined (optional field handling)
  </verify>
  <done>
- getFolderMappings() method exists in TemplateRegistry
- Method returns FolderMappingRule[] | undefined
- Method throws if no active template (consistent with other accessors)
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Obsidian plugin to use template folderMappings</name>
  <files>obsidian-plugin/main.ts</files>
  <action>
Update the Obsidian plugin to retrieve folder mappings from the template registry and pass them to FolderMapper.createFromTemplate().

1. Add import for templateRegistry at the top (after existing imports):
   ```typescript
   import { templateRegistry } from '../src/templates/registry.js';
   import { worldbuildingTemplate } from '../src/templates/builtin/worldbuilding.js';
   ```

2. Update onload() method (around line 172-173). Replace:
   ```typescript
   // Initialize folder mapper with defaults (will be updated when MCP connects)
   this.folderMapper = await FolderMapper.createFromTemplate();
   ```

   With:
   ```typescript
   // Initialize template registry if not already done
   if (!templateRegistry.has('worldbuilding')) {
     templateRegistry.register(worldbuildingTemplate, 'builtin');
     templateRegistry.activate('worldbuilding');
   }

   // Initialize folder mapper from active template config
   const folderMappings = templateRegistry.getFolderMappings();
   this.folderMapper = await FolderMapper.createFromTemplate(folderMappings);
   ```

Note: The plugin currently uses worldbuilding as default. Future work (Phase 16) will allow the plugin to query MCP server for the actual active template. This change is backwards-compatible - worldbuilding template has the same mappings as the old defaults.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- grep "templateRegistry.getFolderMappings" obsidian-plugin/main.ts shows the wiring
- grep "FolderMapper.createFromTemplate(folderMappings)" obsidian-plugin/main.ts shows mappings being passed
  </verify>
  <done>
- Obsidian plugin imports templateRegistry
- Obsidian plugin calls getFolderMappings() to get active template's mappings
- Obsidian plugin passes folderMappings to createFromTemplate()
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Update CLI fix command to use async FolderMapper with template config</name>
  <files>src/cli.ts</files>
  <action>
Update the CLI fix command to use the new async FolderMapper API with template configuration instead of LegacyFolderMapper.

1. Update imports at the top. Change:
   ```typescript
   import { LegacyFolderMapper } from './templates/folder-mapper.js';
   ```
   To:
   ```typescript
   import { FolderMapper } from './templates/folder-mapper.js';
   ```

2. In the fix() function (around line 87), replace:
   ```typescript
   // Initialize folder mapper (using legacy API for backwards compatibility)
   const folderMapper = new LegacyFolderMapper();
   ```
   With:
   ```typescript
   // Initialize folder mapper from active template config
   const folderMappings = templateRegistry.getActive()?.folderMappings;
   const folderMapper = await FolderMapper.createFromTemplate(folderMappings);
   ```

3. Update the usage in the fix loop (around line 113). Replace:
   ```typescript
   const inferredType = folderMapper.inferType(filePath);
   ```
   With:
   ```typescript
   const result = await folderMapper.resolveType(filePath);
   const inferredType = result.types.length === 1 ? result.types[0] :
                        result.types.length > 1 ? result.types[0] : null;
   ```

   This handles the async API and the new ResolveResult structure. When multiple types match (ambiguous), we use the first one (most specific due to sorting). When no types match, we return null.

Note: The template registry is already being initialized and activated in the fix() function (around line 90-92), so folderMappings will be available from the active template.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no type errors
- grep "FolderMapper.createFromTemplate" src/cli.ts shows the new API usage
- grep "LegacyFolderMapper" src/cli.ts returns empty (no more legacy usage)
- grep "resolveType" src/cli.ts shows the async API usage
  </verify>
  <done>
- CLI fix command imports FolderMapper (not LegacyFolderMapper)
- CLI uses createFromTemplate() with template's folderMappings
- CLI uses async resolveType() API
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 4: Add integration test for createFromTemplate with template mappings</name>
  <files>tests/templates/folder-mapper.test.ts</files>
  <action>
Add integration tests verifying that createFromTemplate() correctly uses template folderMappings.

1. Update the existing import at line 8 to include FolderMappingRule:
   ```typescript
   import type { FolderMappingConfig, FolderMappingRule } from '../../src/templates/types.js';
   ```

2. Add a new describe block for template integration tests (at the end of the FolderMapper describe block):

```typescript
describe('createFromTemplate', () => {
  it('should use template folderMappings when provided', async () => {
    const customMappings: FolderMappingRule[] = [
      { folder: '**/CustomFolder/**', types: ['custom_type'] },
      { folder: '**/AnotherFolder/**', types: ['another_type'] },
    ];

    const mapper = await FolderMapper.createFromTemplate(customMappings);

    const result1 = await mapper.resolveType('vault/CustomFolder/test.md');
    expect(result1.types).toEqual(['custom_type']);
    expect(result1.confidence).toBe('exact');

    const result2 = await mapper.resolveType('vault/AnotherFolder/test.md');
    expect(result2.types).toEqual(['another_type']);
    expect(result2.confidence).toBe('exact');
  });

  it('should fall back to defaults when no mappings provided', async () => {
    const mapper = await FolderMapper.createFromTemplate();

    // Should match default worldbuilding patterns
    const result = await mapper.resolveType('vault/Characters/alice.md');
    expect(result.types).toContain('character');
  });

  it('should fall back to defaults when empty array provided', async () => {
    const mapper = await FolderMapper.createFromTemplate([]);

    // Should match default worldbuilding patterns
    const result = await mapper.resolveType('vault/Locations/castle.md');
    expect(result.types).toContain('location');
  });

  it('should pass through fallback type', async () => {
    const customMappings: FolderMappingRule[] = [
      { folder: '**/Known/**', types: ['known'] },
    ];

    const mapper = await FolderMapper.createFromTemplate(customMappings, 'unknown_type');

    const result = await mapper.resolveType('vault/Other/test.md');
    expect(result.types).toEqual(['unknown_type']);
    expect(result.confidence).toBe('fallback');
  });
});
```
  </action>
  <verify>
- `npm test -- tests/templates/folder-mapper.test.ts` passes all tests
- `npm test` passes all tests (no regressions)
- Tests verify: custom mappings used, fallback to defaults, fallback type passed through
  </verify>
  <done>
- Integration tests for createFromTemplate() exist
- Tests verify template mappings are used when provided
- Tests verify fallback to defaults when no mappings
- Tests verify fallback type is passed through
- All tests pass
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Registry Accessor**: `templateRegistry.getFolderMappings()` returns active template's mappings
2. **Obsidian Wiring**: Plugin retrieves and passes folderMappings to createFromTemplate()
3. **CLI Wiring**: fix command uses async FolderMapper with template config
4. **Tests Pass**: `npm test` shows all tests passing including new integration tests
5. **Type Check**: `npx tsc --noEmit` passes
6. **No Legacy API**: LegacyFolderMapper no longer used by fix command

End-to-end verification:
- Template defines `folderMappings: [{ folder: '**/MyFolder/**', types: ['my_type'] }]`
- Registry returns those mappings via getFolderMappings()
- FolderMapper.createFromTemplate(mappings) creates mapper with those rules
- Mapper resolves 'vault/MyFolder/test.md' to ['my_type']
</verification>

<success_criteria>
1. templateRegistry.getFolderMappings() method exists and works
2. Obsidian plugin uses template folderMappings (not hardcoded defaults)
3. CLI fix command uses async FolderMapper with template config
4. Integration tests verify the complete flow
5. TypeScript compilation succeeds
6. All existing tests pass (no regressions)
7. Gap closure: Users CAN now configure folder mappings in config.json
</success_criteria>

<output>
After completion, create `.planning/phases/13-folder-mapping/13-04-SUMMARY.md`
</output>
