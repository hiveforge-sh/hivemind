---
phase: 13-folder-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/templates/types.ts
  - src/templates/folder-mapper.ts
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - "FolderMapper can match glob patterns like **/Characters/**"
    - "Multiple patterns matching same path returns most specific match"
    - "Mapping with multiple types returns ambiguous confidence"
    - "Windows backslash paths match forward-slash patterns"
  artifacts:
    - path: "src/templates/types.ts"
      provides: "FolderMappingConfig, ResolveResult interfaces"
      contains: "FolderMappingConfig"
    - path: "src/templates/folder-mapper.ts"
      provides: "Config-driven async FolderMapper with glob support"
      exports: ["FolderMapper", "ResolveResult", "FolderMappingConfig"]
  key_links:
    - from: "src/templates/folder-mapper.ts"
      to: "picomatch"
      via: "import and pattern matching"
      pattern: "picomatch"
---

<objective>
Refactor FolderMapper to support config-driven glob patterns with specificity-based resolution.

Purpose: Enable folder-to-type mappings that use glob patterns (e.g., `**/Characters/**`) instead of just exact folder names, with "most specific wins" conflict resolution. This shared infrastructure supports both CLI and Obsidian plugin.

Output: Updated `FolderMapper` class with async static factory, glob matching via picomatch, and specificity algorithm.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-folder-mapping/13-CONTEXT.md
@.planning/phases/13-folder-mapping/13-RESEARCH.md

# Existing files to refactor
@src/templates/types.ts
@src/templates/folder-mapper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install picomatch and add types</name>
  <files>package.json, src/templates/types.ts</files>
  <action>
1. Install picomatch as a production dependency:
   ```bash
   npm install picomatch
   npm install -D @types/picomatch
   ```

2. Update `src/templates/types.ts` to add new interfaces for config-driven folder mapping:

```typescript
/**
 * Configuration for folder-to-type mappings.
 * Lives inside template config - each template defines its own mappings.
 */
export interface FolderMappingConfig {
  /** Array of folder-to-type mapping rules */
  mappings: FolderMappingRule[];
  /** Optional fallback type when no mapping matches */
  fallbackType?: string;
}

/**
 * Single folder-to-type mapping rule.
 * Supports glob patterns and multiple types per folder.
 */
export interface FolderMappingRule {
  /**
   * Glob pattern to match folder paths (e.g., "**/Characters/**", "People/")
   * Patterns are relative to vault root. Use forward slashes.
   */
  folder: string;

  /**
   * Entity type(s) to assign when pattern matches.
   * Single type: file is assigned that type.
   * Multiple types: consumer should prompt user to choose.
   */
  types: string[];
}

/**
 * Result of resolving a file path to entity type(s).
 */
export interface ResolveResult {
  /** Resolved entity type(s) */
  types: string[];

  /** Pattern that matched (null if fallback or no match) */
  matchedPattern: string | null;

  /**
   * Confidence level:
   * - 'exact': Single type from exact pattern match
   * - 'ambiguous': Multiple types, consumer should prompt
   * - 'fallback': Used fallback type (no pattern matched)
   * - 'none': No match and no fallback
   */
  confidence: 'exact' | 'ambiguous' | 'fallback' | 'none';
}
```

Keep existing `FolderMapping` interface for backwards compatibility (used by old code).
  </action>
  <verify>
- `npm ls picomatch` shows picomatch as a direct dependency
- `npx tsc --noEmit` passes (types compile)
  </verify>
  <done>picomatch installed, FolderMappingConfig/ResolveResult interfaces added to types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Refactor FolderMapper with glob and specificity</name>
  <files>src/templates/folder-mapper.ts</files>
  <action>
Refactor `FolderMapper` to support:
1. Config-driven mappings (instead of hardcoded defaults)
2. Glob pattern matching via picomatch
3. Specificity-based conflict resolution ("most specific wins")
4. Async static factory pattern
5. Path normalization (backslashes to forward slashes)

Implementation structure:

```typescript
import picomatch from 'picomatch';
import type { FolderMappingConfig, FolderMappingRule, ResolveResult, FolderMapping } from './types.js';

/**
 * Compiled mapping with pre-built matcher and specificity score.
 */
interface CompiledMapping {
  rule: FolderMappingRule;
  matcher: (path: string) => boolean;
  specificity: number;
}

/**
 * Calculate pattern specificity for "most specific wins" resolution.
 * Higher score = more specific pattern.
 */
function calculateSpecificity(pattern: string): number {
  let score = 0;

  // Base: character count (longer = more specific)
  score += pattern.length;

  // Wildcards reduce specificity
  const doubleStars = (pattern.match(/\*\*/g) || []).length;
  const singleStars = (pattern.match(/(?<!\*)\*(?!\*)/g) || []).length;
  score -= doubleStars * 10;  // ** is very generic
  score -= singleStars * 5;   // * is somewhat generic

  // Path depth increases specificity
  const depth = pattern.split('/').filter(s => s.length > 0).length;
  score += depth * 8;

  // Literal segments (no wildcards) are highly specific
  const segments = pattern.split('/').filter(s => s.length > 0);
  const literalSegs = segments.filter(s => !s.includes('*')).length;
  score += literalSegs * 12;

  return score;
}

/**
 * Normalize path to forward slashes for glob matching.
 * Windows backslashes become forward slashes.
 */
function normalizePath(filePath: string): string {
  return filePath.replace(/\\/g, '/');
}

/**
 * FolderMapper resolves file paths to entity types using glob patterns.
 *
 * Shared between CLI and Obsidian plugin - no duplication.
 * Uses picomatch for fast, standards-compliant glob matching.
 */
export class FolderMapper {
  private compiledMappings: CompiledMapping[];
  private fallbackType?: string;

  /**
   * Private constructor - use FolderMapper.create() instead.
   */
  private constructor(
    compiledMappings: CompiledMapping[],
    fallbackType?: string
  ) {
    this.compiledMappings = compiledMappings;
    this.fallbackType = fallbackType;
  }

  /**
   * Create a FolderMapper from configuration.
   *
   * Validates patterns and pre-compiles matchers for performance.
   * Throws on invalid glob patterns.
   *
   * @param config - Folder mapping configuration
   * @returns Promise resolving to configured FolderMapper
   */
  static async create(config: FolderMappingConfig): Promise<FolderMapper> {
    const compiled: CompiledMapping[] = [];

    for (const rule of config.mappings) {
      // Normalize pattern (backslashes to forward slashes)
      const normalizedPattern = normalizePath(rule.folder);

      // Validate pattern by attempting to parse
      try {
        picomatch.parse(normalizedPattern);
      } catch (error) {
        throw new Error(`Invalid glob pattern "${rule.folder}": ${(error as Error).message}`);
      }

      compiled.push({
        rule: { ...rule, folder: normalizedPattern },
        matcher: picomatch(normalizedPattern),
        specificity: calculateSpecificity(normalizedPattern),
      });
    }

    // Sort by specificity (highest first) for "most specific wins"
    compiled.sort((a, b) => b.specificity - a.specificity);

    return new FolderMapper(compiled, config.fallbackType);
  }

  /**
   * Create a FolderMapper with default worldbuilding mappings.
   * Convenience method for backwards compatibility.
   */
  static async createWithDefaults(): Promise<FolderMapper> {
    return FolderMapper.create({
      mappings: DEFAULT_FOLDER_MAPPINGS.map(m => ({
        folder: `**/${m.pattern}/**`,
        types: [m.entityType],
      })),
    });
  }

  /**
   * Resolve a file path to entity type(s).
   *
   * Async API for future extensibility (e.g., loading config from disk).
   *
   * @param filePath - File path (absolute or vault-relative)
   * @returns Resolve result with types and confidence
   */
  async resolveType(filePath: string): Promise<ResolveResult> {
    const normalized = normalizePath(filePath);

    // Find first matching pattern (already sorted by specificity)
    for (const compiled of this.compiledMappings) {
      if (compiled.matcher(normalized)) {
        const types = compiled.rule.types;
        return {
          types,
          matchedPattern: compiled.rule.folder,
          confidence: types.length === 1 ? 'exact' : 'ambiguous',
        };
      }
    }

    // No match - use fallback or return none
    if (this.fallbackType) {
      return {
        types: [this.fallbackType],
        matchedPattern: null,
        confidence: 'fallback',
      };
    }

    return {
      types: [],
      matchedPattern: null,
      confidence: 'none',
    };
  }

  /**
   * Resolve types for multiple file paths.
   *
   * @param filePaths - Array of file paths
   * @returns Map of file path to resolve result
   */
  async resolveTypes(filePaths: string[]): Promise<Map<string, ResolveResult>> {
    const results = new Map<string, ResolveResult>();
    for (const path of filePaths) {
      results.set(path, await this.resolveType(path));
    }
    return results;
  }

  /**
   * Get all configured mappings.
   */
  getMappings(): FolderMappingRule[] {
    return this.compiledMappings.map(c => c.rule);
  }
}

// ===== Legacy API for backwards compatibility =====

/**
 * Default folder-to-type mappings for common worldbuilding folder structures.
 * @deprecated Use FolderMapper.create() with explicit config instead.
 */
export const DEFAULT_FOLDER_MAPPINGS: FolderMapping[] = [
  // Character mappings
  { pattern: 'characters', entityType: 'character' },
  { pattern: 'people', entityType: 'character' },
  { pattern: 'npcs', entityType: 'character' },
  { pattern: 'pcs', entityType: 'character' },
  { pattern: 'cast', entityType: 'character' },
  // ... (keep all existing defaults)
  // Location mappings
  { pattern: 'locations', entityType: 'location' },
  { pattern: 'places', entityType: 'location' },
  { pattern: 'geography', entityType: 'location' },
  { pattern: 'world', entityType: 'location' },
  { pattern: 'regions', entityType: 'location' },
  { pattern: 'cities', entityType: 'location' },
  { pattern: 'towns', entityType: 'location' },
  // Event mappings
  { pattern: 'events', entityType: 'event' },
  { pattern: 'timeline', entityType: 'event' },
  { pattern: 'history', entityType: 'event' },
  { pattern: 'sessions', entityType: 'event' },
  // Faction mappings
  { pattern: 'factions', entityType: 'faction' },
  { pattern: 'organizations', entityType: 'faction' },
  { pattern: 'groups', entityType: 'faction' },
  { pattern: 'guilds', entityType: 'faction' },
  { pattern: 'houses', entityType: 'faction' },
  // Lore mappings
  { pattern: 'lore', entityType: 'lore' },
  { pattern: 'mythology', entityType: 'lore' },
  { pattern: 'magic', entityType: 'lore' },
  { pattern: 'culture', entityType: 'lore' },
  { pattern: 'religion', entityType: 'lore' },
  // Asset mappings
  { pattern: 'assets', entityType: 'asset' },
  { pattern: 'images', entityType: 'asset' },
  { pattern: 'media', entityType: 'asset' },
  // Reference mappings
  { pattern: 'references', entityType: 'reference' },
  { pattern: 'sources', entityType: 'reference' },
  { pattern: 'inspiration', entityType: 'reference' },
  { pattern: 'notes', entityType: 'reference' },
  { pattern: 'meta', entityType: 'reference' },
];

/**
 * Legacy FolderMapper using simple string matching.
 * @deprecated Use async FolderMapper.create() for glob support.
 */
export class LegacyFolderMapper {
  private mappings: Map<string, string>;

  constructor(customMappings: FolderMapping[] = []) {
    this.mappings = new Map();
    for (const mapping of DEFAULT_FOLDER_MAPPINGS) {
      this.mappings.set(mapping.pattern.toLowerCase(), mapping.entityType);
    }
    for (const mapping of customMappings) {
      this.mappings.set(mapping.pattern.toLowerCase(), mapping.entityType);
    }
  }

  inferType(filePath: string): string | null {
    const parts = filePath.toLowerCase().split(/[/\\]/);
    for (const part of parts) {
      const exactMatch = this.mappings.get(part);
      if (exactMatch) return exactMatch;
      for (const [pattern, entityType] of this.mappings) {
        if (part.startsWith(pattern)) return entityType;
      }
    }
    return null;
  }

  inferTypes(filePaths: string[]): Map<string, string | null> {
    const results = new Map<string, string | null>();
    for (const path of filePaths) {
      results.set(path, this.inferType(path));
    }
    return results;
  }

  getMappings(): FolderMapping[] {
    return Array.from(this.mappings.entries()).map(([pattern, entityType]) => ({
      pattern,
      entityType,
    }));
  }

  addMapping(pattern: string, entityType: string): void {
    this.mappings.set(pattern.toLowerCase(), entityType);
  }
}

/**
 * Legacy singleton instance.
 * @deprecated Use async FolderMapper.create() for glob support.
 */
export const folderMapper = new LegacyFolderMapper();
```

Key implementation notes:
- Private constructor + static `create()` factory for async initialization
- `createWithDefaults()` convenience method for existing code
- `LegacyFolderMapper` preserves exact current API for existing callers
- Path normalization handles Windows backslashes
- Specificity algorithm: length + depth bonus - wildcard penalties
- Patterns sorted by specificity at creation time (O(1) lookup)
- Case-sensitive matching (per phase decision)
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `npm run build` succeeds
  </verify>
  <done>FolderMapper refactored with glob support, specificity resolution, and async API</done>
</task>

<task type="auto">
  <name>Task 3: Export types and update index</name>
  <files>src/templates/index.ts</files>
  <action>
Update the templates index to export new types and the refactored FolderMapper:

```typescript
// In src/templates/index.ts (or create if it doesn't exist)
export {
  FolderMapper,
  LegacyFolderMapper,
  folderMapper,
  DEFAULT_FOLDER_MAPPINGS,
} from './folder-mapper.js';

export type {
  FolderMappingConfig,
  FolderMappingRule,
  ResolveResult,
  FolderMapping,
} from './types.js';
```

If no index.ts exists, ensure types are exported directly from types.ts.

Verify exports are accessible from the package by checking src/index.ts imports.
  </action>
  <verify>
- Types can be imported: `import { FolderMapper, ResolveResult } from './templates/folder-mapper.js'`
- `npm run build` succeeds
  </verify>
  <done>New types and FolderMapper exported from templates module</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Types compile**: `npx tsc --noEmit` passes without errors
2. **Build succeeds**: `npm run build` completes successfully
3. **Picomatch installed**: `npm ls picomatch` shows direct dependency
4. **Exports work**: Can import `FolderMapper`, `ResolveResult`, `FolderMappingConfig` from templates

Manual verification (quick):
```typescript
// Test in Node REPL or temporary file
import { FolderMapper } from './dist/templates/folder-mapper.js';

const mapper = await FolderMapper.create({
  mappings: [
    { folder: '**/Characters/**', types: ['character'] },
    { folder: '**/People/Heroes/**', types: ['character'] },
  ]
});

// Should match more specific pattern
const result = await mapper.resolveType('vault/People/Heroes/John.md');
console.log(result); // { types: ['character'], matchedPattern: '**/People/Heroes/**', confidence: 'exact' }
```
</verification>

<success_criteria>
- FolderMapper.create() accepts FolderMappingConfig with glob patterns
- resolveType() returns ResolveResult with types, matchedPattern, confidence
- Windows paths (backslashes) work with forward-slash patterns
- Most specific pattern wins when multiple patterns match
- Invalid glob patterns throw during create() not during resolveType()
- Legacy API (folderMapper singleton, inferType) still works
</success_criteria>

<output>
After completion, create `.planning/phases/13-folder-mapping/13-01-SUMMARY.md`
</output>
