---
phase: 13-folder-mapping
plan: 02
type: tdd
wave: 2
depends_on: ["13-01"]
files_modified:
  - src/templates/__tests__/folder-mapper.test.ts
  - obsidian-plugin/main.ts
autonomous: true

must_haves:
  truths:
    - "Tests verify glob matching, specificity, and path normalization"
    - "Obsidian plugin uses shared FolderMapper (no duplicated logic)"
    - "Both Windows and Unix paths work in tests"
  artifacts:
    - path: "src/templates/__tests__/folder-mapper.test.ts"
      provides: "Comprehensive test coverage for FolderMapper"
      min_lines: 100
    - path: "obsidian-plugin/main.ts"
      provides: "Updated plugin using shared FolderMapper"
      contains: "import.*FolderMapper"
  key_links:
    - from: "obsidian-plugin/main.ts"
      to: "src/templates/folder-mapper.ts"
      via: "relative import"
      pattern: "from.*templates/folder-mapper"
---

<objective>
Add comprehensive tests for FolderMapper and update Obsidian plugin to use shared infrastructure.

Purpose: Ensure FolderMapper handles all edge cases (glob patterns, specificity, Windows paths) and eliminate duplication between CLI and Obsidian plugin. The plugin currently has its own hardcoded `FOLDER_TYPE_MAPPINGS` and `inferTypeFromPath` function - these must use the shared FolderMapper.

Output: Test file with full coverage, Obsidian plugin refactored to import shared FolderMapper.
</objective>

<execution_context>
@C:\Users\Preston\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Preston\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-folder-mapping/13-CONTEXT.md
@.planning/phases/13-folder-mapping/13-RESEARCH.md

# Prior plan summary
@.planning/phases/13-folder-mapping/13-01-SUMMARY.md

# Files to modify
@obsidian-plugin/main.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create comprehensive FolderMapper tests</name>
  <files>src/templates/__tests__/folder-mapper.test.ts</files>
  <action>
Create test file with comprehensive coverage for FolderMapper:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { FolderMapper, LegacyFolderMapper, DEFAULT_FOLDER_MAPPINGS } from '../folder-mapper.js';
import type { FolderMappingConfig, ResolveResult } from '../types.js';

describe('FolderMapper', () => {
  describe('create()', () => {
    it('should create mapper with valid config', async () => {
      const config: FolderMappingConfig = {
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
        ],
      };

      const mapper = await FolderMapper.create(config);
      expect(mapper).toBeInstanceOf(FolderMapper);
    });

    it('should throw on invalid glob pattern', async () => {
      const config: FolderMappingConfig = {
        mappings: [
          { folder: '**/[unclosed', types: ['character'] },
        ],
      };

      await expect(FolderMapper.create(config)).rejects.toThrow('Invalid glob pattern');
    });

    it('should normalize backslashes in patterns', async () => {
      const config: FolderMappingConfig = {
        mappings: [
          { folder: '**\\Characters\\**', types: ['character'] },
        ],
      };

      const mapper = await FolderMapper.create(config);
      const result = await mapper.resolveType('vault/Characters/hero.md');
      expect(result.confidence).toBe('exact');
    });
  });

  describe('resolveType()', () => {
    let mapper: FolderMapper;

    beforeEach(async () => {
      mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
          { folder: '**/Locations/**', types: ['location'] },
          { folder: '**/Notes/**', types: ['lore', 'event'] },
        ],
      });
    });

    it('should match simple glob pattern', async () => {
      const result = await mapper.resolveType('vault/Characters/hero.md');

      expect(result).toEqual({
        types: ['character'],
        matchedPattern: '**/Characters/**',
        confidence: 'exact',
      });
    });

    it('should return ambiguous for multiple types', async () => {
      const result = await mapper.resolveType('vault/Notes/meeting.md');

      expect(result).toEqual({
        types: ['lore', 'event'],
        matchedPattern: '**/Notes/**',
        confidence: 'ambiguous',
      });
    });

    it('should return none when no match and no fallback', async () => {
      const result = await mapper.resolveType('vault/Random/file.md');

      expect(result).toEqual({
        types: [],
        matchedPattern: null,
        confidence: 'none',
      });
    });

    it('should normalize Windows backslash paths', async () => {
      const result = await mapper.resolveType('vault\\Characters\\hero.md');

      expect(result.confidence).toBe('exact');
      expect(result.types).toEqual(['character']);
    });

    it('should handle deeply nested paths', async () => {
      const result = await mapper.resolveType('vault/Characters/NPCs/Merchants/shopkeeper.md');

      expect(result.types).toEqual(['character']);
    });

    it('should be case-sensitive', async () => {
      const result = await mapper.resolveType('vault/characters/hero.md');

      // Lowercase 'characters' should NOT match '**/Characters/**'
      expect(result.confidence).toBe('none');
    });
  });

  describe('specificity resolution', () => {
    it('should prefer more specific pattern over generic', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/People/**', types: ['character'] },
          { folder: '**/People/Heroes/**', types: ['hero'] },
        ],
      });

      // More specific pattern should win
      const result = await mapper.resolveType('vault/People/Heroes/John.md');

      expect(result.types).toEqual(['hero']);
      expect(result.matchedPattern).toBe('**/People/Heroes/**');
    });

    it('should prefer literal segments over wildcards', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/**/Characters/**', types: ['generic'] },
          { folder: 'World/Characters/**', types: ['specific'] },
        ],
      });

      const result = await mapper.resolveType('World/Characters/hero.md');

      expect(result.types).toEqual(['specific']);
    });

    it('should handle multiple wildcards with different specificity', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**', types: ['catchall'] },
          { folder: '**/folder/**', types: ['medium'] },
          { folder: 'exact/path/**', types: ['high'] },
        ],
      });

      const result = await mapper.resolveType('exact/path/file.md');
      expect(result.types).toEqual(['high']);
    });
  });

  describe('fallback type', () => {
    it('should use fallback when no pattern matches', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
        ],
        fallbackType: 'reference',
      });

      const result = await mapper.resolveType('vault/Random/file.md');

      expect(result).toEqual({
        types: ['reference'],
        matchedPattern: null,
        confidence: 'fallback',
      });
    });

    it('should not use fallback when pattern matches', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
        ],
        fallbackType: 'reference',
      });

      const result = await mapper.resolveType('vault/Characters/hero.md');

      expect(result.confidence).toBe('exact');
      expect(result.types).toEqual(['character']);
    });
  });

  describe('resolveTypes()', () => {
    it('should resolve multiple paths', async () => {
      const mapper = await FolderMapper.create({
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
          { folder: '**/Locations/**', types: ['location'] },
        ],
      });

      const results = await mapper.resolveTypes([
        'vault/Characters/hero.md',
        'vault/Locations/city.md',
        'vault/Random/file.md',
      ]);

      expect(results.size).toBe(3);
      expect(results.get('vault/Characters/hero.md')?.types).toEqual(['character']);
      expect(results.get('vault/Locations/city.md')?.types).toEqual(['location']);
      expect(results.get('vault/Random/file.md')?.confidence).toBe('none');
    });
  });

  describe('getMappings()', () => {
    it('should return configured mappings', async () => {
      const config: FolderMappingConfig = {
        mappings: [
          { folder: '**/Characters/**', types: ['character'] },
          { folder: '**/Locations/**', types: ['location'] },
        ],
      };

      const mapper = await FolderMapper.create(config);
      const mappings = mapper.getMappings();

      expect(mappings).toHaveLength(2);
      expect(mappings[0].folder).toContain('Characters');
      expect(mappings[1].folder).toContain('Locations');
    });
  });

  describe('createWithDefaults()', () => {
    it('should create mapper with default worldbuilding mappings', async () => {
      const mapper = await FolderMapper.createWithDefaults();

      const charResult = await mapper.resolveType('vault/characters/hero.md');
      const locResult = await mapper.resolveType('vault/locations/city.md');

      expect(charResult.types).toEqual(['character']);
      expect(locResult.types).toEqual(['location']);
    });
  });
});

describe('LegacyFolderMapper', () => {
  it('should maintain backwards compatibility', () => {
    const mapper = new LegacyFolderMapper();

    expect(mapper.inferType('vault/characters/hero.md')).toBe('character');
    expect(mapper.inferType('vault/locations/city.md')).toBe('location');
    expect(mapper.inferType('vault/random/file.md')).toBeNull();
  });

  it('should support custom mappings', () => {
    const mapper = new LegacyFolderMapper([
      { pattern: 'custom', entityType: 'custom-type' },
    ]);

    expect(mapper.inferType('vault/custom/file.md')).toBe('custom-type');
  });

  it('should support prefix matching', () => {
    const mapper = new LegacyFolderMapper();

    // 'characters-main' should match 'characters' prefix
    expect(mapper.inferType('vault/characters-main/hero.md')).toBe('character');
  });
});

describe('DEFAULT_FOLDER_MAPPINGS', () => {
  it('should contain expected entity types', () => {
    const types = new Set(DEFAULT_FOLDER_MAPPINGS.map(m => m.entityType));

    expect(types).toContain('character');
    expect(types).toContain('location');
    expect(types).toContain('event');
    expect(types).toContain('faction');
    expect(types).toContain('lore');
    expect(types).toContain('asset');
    expect(types).toContain('reference');
  });
});
```

Run tests to verify: `npm test src/templates/__tests__/folder-mapper.test.ts`
  </action>
  <verify>
- `npm test src/templates/__tests__/folder-mapper.test.ts` passes all tests
- Coverage includes: glob matching, specificity, path normalization, fallback, legacy API
  </verify>
  <done>Comprehensive tests written and passing for FolderMapper</done>
</task>

<task type="auto">
  <name>Task 2: Update Obsidian plugin to use shared FolderMapper</name>
  <files>obsidian-plugin/main.ts</files>
  <action>
Refactor the Obsidian plugin to use the shared FolderMapper instead of duplicated logic.

Current state (to remove):
- Lines 29-77: Hardcoded `FOLDER_TYPE_MAPPINGS` Map
- Lines 82-101: Duplicated `inferTypeFromPath` function

Changes:

1. Add import at top of file:
```typescript
import { FolderMapper, DEFAULT_FOLDER_MAPPINGS, LegacyFolderMapper } from '../src/templates/folder-mapper';
import type { ResolveResult } from '../src/templates/types';
```

2. Remove the hardcoded `FOLDER_TYPE_MAPPINGS` Map (lines 29-77)

3. Remove the duplicated `inferTypeFromPath` function (lines 82-101)

4. Add FolderMapper instance to plugin class:
```typescript
export default class HivemindPlugin extends Plugin {
  settings: HivemindSettings;
  private mcpProcess?: ChildProcess;
  // ... existing fields ...
  private folderMapper?: FolderMapper;

  async onload() {
    await this.loadSettings();

    // Initialize folder mapper with defaults
    this.folderMapper = await FolderMapper.createWithDefaults();

    // ... rest of onload ...
  }
```

5. Update `checkMissingFrontmatter` method to use shared mapper:
```typescript
private async checkMissingFrontmatter(file: TFile | null) {
  if (!file) {
    new Notice('No active file');
    return;
  }

  try {
    const content = await this.app.vault.read(file);
    const cache = this.app.metadataCache.getFileCache(file);

    const frontmatter = cache?.frontmatter || {};
    let noteType = frontmatter.type;

    // If no type, use shared FolderMapper
    if (!noteType && this.folderMapper) {
      const result = await this.folderMapper.resolveType(file.path);

      if (result.confidence === 'exact') {
        // Single type - show inference confirmation modal
        new TypeInferenceModal(this.app, this, file, result.types[0]).open();
        return;
      } else if (result.confidence === 'ambiguous') {
        // Multiple types - show selection modal with suggested types
        new TypeSelectionModal(this.app, this, file, result.types).open();
        return;
      } else {
        // No match - show full type selection
        new TypeSelectionModal(this.app, this, file).open();
        return;
      }
    }

    // ... rest of method unchanged ...
  }
}
```

6. Update `TypeSelectionModal` constructor to accept optional suggested types:
```typescript
class TypeSelectionModal extends Modal {
  plugin: HivemindPlugin;
  file: TFile;
  suggestedTypes?: string[];  // NEW: optional suggested types

  constructor(app: App, plugin: HivemindPlugin, file: TFile, suggestedTypes?: string[]) {
    super(app);
    this.plugin = plugin;
    this.file = file;
    this.suggestedTypes = suggestedTypes;
  }

  onOpen() {
    const { contentEl } = this;

    contentEl.createEl('h2', { text: 'Select Entity Type' });

    // If we have suggested types (from ambiguous mapping), show them first
    if (this.suggestedTypes && this.suggestedTypes.length > 0) {
      contentEl.createEl('p', {
        text: 'Suggested types based on folder:',
        cls: 'setting-item-description'
      });

      const suggestedGrid = contentEl.createDiv({ cls: 'type-selection-grid' });
      // ... render suggested types as buttons ...
    }

    // ... rest of modal unchanged ...
  }
}
```

Note: The import path `'../src/templates/folder-mapper'` works because the Obsidian plugin is in a sibling directory to src/. The esbuild config bundles this into main.js.
  </action>
  <verify>
- `npm run build` in obsidian-plugin/ succeeds (or project root if shared build)
- No duplicate `FOLDER_TYPE_MAPPINGS` or `inferTypeFromPath` in obsidian-plugin/main.ts
- Import of FolderMapper present in obsidian-plugin/main.ts
  </verify>
  <done>Obsidian plugin refactored to use shared FolderMapper, no duplication</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Tests pass**: `npm test` passes with new folder-mapper tests
2. **No duplication**: `grep -c "FOLDER_TYPE_MAPPINGS" obsidian-plugin/main.ts` returns 0
3. **Shared import**: `grep "FolderMapper" obsidian-plugin/main.ts` shows import statement
4. **Plugin builds**: Obsidian plugin compiles successfully

Test coverage should include:
- Glob pattern matching (exact, wildcard, nested)
- Specificity resolution (more specific wins)
- Path normalization (Windows backslashes)
- Multiple types (ambiguous confidence)
- Fallback type behavior
- Legacy API backwards compatibility
</verification>

<success_criteria>
- All new tests pass
- Obsidian plugin uses FolderMapper.resolveType() instead of inferTypeFromPath()
- Hardcoded FOLDER_TYPE_MAPPINGS removed from plugin
- Plugin handles exact, ambiguous, and none confidence levels appropriately
- Plugin compiles and bundles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/13-folder-mapping/13-02-SUMMARY.md`
</output>
